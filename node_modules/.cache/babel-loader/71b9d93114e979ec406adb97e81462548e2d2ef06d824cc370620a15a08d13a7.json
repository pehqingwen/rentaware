{"ast":null,"code":"import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-b8036b75.js';\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n  var _super = _createSuper(BlankLine);\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n  _createClass(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }]);\n  return BlankLine;\n}(Node);\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n  var _super = _createSuper(CollectionItem);\n  function CollectionItem(type, props) {\n    var _this;\n    _classCallCheck(this, CollectionItem);\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n  _createClass(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n        src = context.src;\n      var atLineStart = context.atLineStart,\n        lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n          offset = Node.endOfIndent(src, lineStart);\n        }\n        ch = src[offset];\n      }\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n        node = this.node,\n        range = this.range,\n        value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n  return CollectionItem;\n}(Node);\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n  var _super = _createSuper(Comment);\n  function Comment() {\n    _classCallCheck(this, Comment);\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n  return Comment;\n}(Node);\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n        indent = _n$context.indent,\n        lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n  var _super = _createSuper(Collection);\n  function Collection(firstItem) {\n    var _this;\n    _classCallCheck(this, Collection);\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n  _createClass(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n        src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n          ch = src[offset];\n          atLineStart = true;\n        }\n        if (!ch) {\n          break;\n        }\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n        items = this.items,\n        range = this.range,\n        value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n          atLineStart = _item$context.atLineStart,\n          indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n  return Collection;\n}(Node);\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n  var _super = _createSuper(Directive);\n  function Directive() {\n    var _this;\n    _classCallCheck(this, Directive);\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n  _createClass(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n  return Directive;\n}(Node);\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n  var _super = _createSuper(Document);\n  function Document() {\n    var _this;\n    _classCallCheck(this, Document);\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n            break;\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n            return offset;\n        }\n      }\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n        parseNode = _this$context.parseNode,\n        src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n            lineStart = offset;\n            break;\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n      this.valueRange.end = offset;\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n            case undefined:\n              break;\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n        directives = this.directives,\n        value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n  return Document;\n}(Node);\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n  var _super = _createSuper(Alias);\n  function Alias() {\n    _classCallCheck(this, Alias);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n  return Alias;\n}(Node);\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n  var _super = _createSuper(BlockValue);\n  function BlockValue(type, props) {\n    var _this;\n    _classCallCheck(this, BlockValue);\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n  _createClass(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n        start = _this$valueRange.start,\n        end = _this$valueRange.end;\n      var _this$context = this.context,\n        indent = _this$context.indent,\n        src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n      var keepStart = end + 1;\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n        var _ch = src[i];\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n      while (true) {\n        var ch = src[offset];\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n        indent = _this$context2.indent,\n        src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n  return BlockValue;\n}(Node);\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n  var _super = _createSuper(FlowCollection);\n  function FlowCollection(type, props) {\n    var _this;\n    _classCallCheck(this, FlowCollection);\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n        src = context.src;\n      var indent = context.indent,\n        lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n              offset = Node.endOfIndent(src, lineStart);\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' ||\n              // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n      this.valueRange = new Range(start, offset + 1);\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n        items = this.items,\n        range = this.range,\n        value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n  return FlowCollection;\n}(Node);\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n  var _super = _createSuper(QuoteDouble);\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n    return _super.apply(this, arguments);\n  }\n  _createClass(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n        start = _this$valueRange.start,\n        end = _this$valueRange.end;\n      var _this$context = this.context,\n        indent = _this$context.indent,\n        src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n            fold = _Node$foldNewline.fold,\n            offset = _Node$foldNewline.offset,\n            error = _Node$foldNewline.error;\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n            case '\"':\n              str += '\"';\n              break;\n            case '/':\n              str += '/';\n              break;\n            case '\\\\':\n              str += '\\\\';\n              break;\n            case '\\t':\n              str += '\\t';\n              break;\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n              break;\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n      return offset + 1;\n    }\n  }]);\n  return QuoteDouble;\n}(Node);\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n  var _super = _createSuper(QuoteSingle);\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n    return _super.apply(this, arguments);\n  }\n  _createClass(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n        start = _this$valueRange.start,\n        end = _this$valueRange.end;\n      var _this$context = this.context,\n        indent = _this$context.indent,\n        src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n            fold = _Node$foldNewline.fold,\n            offset = _Node$foldNewline.offset,\n            error = _Node$foldNewline.error;\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n      return offset + 1;\n    }\n  }]);\n  return QuoteSingle;\n}(Node);\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      atLineStart = _ref.atLineStart,\n      inCollection = _ref.inCollection,\n      inFlow = _ref.inFlow,\n      indent = _ref.indent,\n      lineStart = _ref.lineStart,\n      parent = _ref.parent;\n    _classCallCheck(this, ParseContext);\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n      var _context$parseProps = context.parseProps(start),\n        props = _context$parseProps.props,\n        type = _context$parseProps.type,\n        valueStart = _context$parseProps.valueStart;\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n      return node;\n    });\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n        inFlow = this.inFlow,\n        src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n        parent = this.parent,\n        src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n          do {\n            lineStart = inEnd + 1;\n            inEnd = Node.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n        case '>':\n          return Type.BLOCK_FOLDED;\n        case '|':\n          return Type.BLOCK_LITERAL;\n        case '{':\n          return Type.FLOW_MAP;\n        case '[':\n          return Type.FLOW_SEQ;\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n  var documents = [];\n  var offset = 0;\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n    var crOffset = 0;\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n    cr.splice(0, cr.length);\n    return true;\n  };\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n  return documents;\n}\nexport { parse };","map":{"version":3,"names":["j","_inherits","k","_createSuper","c","_classCallCheck","T","Type","b","_createClass","R","Range","N","Node","g","YAMLSemanticError","l","_get","m","_getPrototypeOf","Y","YAMLSyntaxError","C","Char","e","_defineProperty","P","PlainValue","BlankLine","_Node","_super","call","BLANK_LINE","key","get","value","parse","context","start","range","CollectionItem","type","props","_this","node","includesTrailingLines","parseNode","src","atLineStart","lineStart","SEQ_ITEM","error","indent","offset","endOfWhiteSpace","ch","inlineComment","comments","blankLine","_end","endOfLine","push","wsEnd","length","endOfIndent","nextNodeIsIndented","inCollection","parent","items","contents","Array","prototype","apply","end","valueRange","setOrigRanges","cr","toString","str","slice","String","addStringTerminator","Comment","COMMENT","parseComment","grabCollectionEndComments","cnode","Collection","len","ci","i","n","_n$context","ca","splice","prevEnd","firstItem","SEQ","MAP","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","nextContentHasIndent","comment","atBlank","next","msg","_next","_msg","ls","prev","forEach","item","_item$context","_i","Directive","DIRECTIVE","name","raw","rawValue","trim","split","parseName","parseParameters","Document","DOCUMENT","directives","directivesEndMarker","documentEndMarker","parseDirectives","hasDirectives","atDocumentBoundary","DIRECTIVES_END","startCommentOrEndBlankLine","directive","parseContents","_this$context","DOCUMENT_END","iEnd","inFlow","_comment","undefined","root","charCodeAt","setOrigRange","join","Alias","arguments","endOfIdentifier","Chomp","CLIP","KEEP","STRIP","BlockValue","blockIndent","chomping","header","_this$valueRange","isEmpty","lastNewLine","keepStart","bi","folded","BLOCK_FOLDED","atStart","sep","prevMoreIndented","_ch","lineEnd","line","parseBlockHeader","Number","parseBlockValue","_this$context2","explicit","valueEnd","minBlockIndent","endOfBlockIndent","_ch2","lineIndent","_src","concat","FlowCollection","prevNodeIsJsonLike","idx","jsonLike","char","origOffset","nodes","filter","prefix","QuoteDouble","errors","_Node$foldNewline","foldNewline","fold","parseCharCode","substr","wsStart","cc","ok","test","code","parseInt","NaN","isNaN","fromCodePoint","endOfQuote","QuoteSingle","createNewNode","ALIAS","BLOCK_LITERAL","FLOW_MAP","FLOW_SEQ","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","ParseContext","orig","_ref","overlay","_context$parseProps","parseProps","valueStart","Error","parseEnd","source","nodeStartsCollection","collection","lineHasProps","ANCHOR","TAG","inEnd","indentDiff","noIndicatorAsIndent","parseType","indexOf","replace","match","documents","doc","crOffset"],"sources":["C:/Users/pehqi/my-react-app/node_modules/yaml/browser/dist/parse-cst.js"],"sourcesContent":["import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-b8036b75.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = Node.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,YAAY,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,IAAI,EAAEC,CAAC,IAAIC,YAAY,EAAEC,CAAC,IAAIC,KAAK,EAAEC,CAAC,IAAIC,IAAI,EAAEC,CAAC,IAAIC,iBAAiB,EAAEC,CAAC,IAAIC,IAAI,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,IAAI,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,UAAU,QAAQ,0BAA0B;AAExR,IAAIC,SAAS,GAAG,aAAa,UAAUC,KAAK,EAAE;EAC5C5B,SAAS,CAAC2B,SAAS,EAAEC,KAAK,CAAC;EAE3B,IAAIC,MAAM,GAAG3B,YAAY,CAACyB,SAAS,CAAC;EAEpC,SAASA,SAASA,CAAA,EAAG;IACnBvB,eAAe,CAAC,IAAI,EAAEuB,SAAS,CAAC;IAEhC,OAAOE,MAAM,CAACC,IAAI,CAAC,IAAI,EAAExB,IAAI,CAACyB,UAAU,CAAC;EAC3C;EACA;;EAGAvB,YAAY,CAACmB,SAAS,EAAE,CAAC;IACvBK,GAAG,EAAE,uBAAuB;IAC5BC,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB;MACA;MACA,OAAO,IAAI;IACb;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDD,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAI,CAACE,KAAK,GAAG,IAAI5B,KAAK,CAAC2B,KAAK,EAAEA,KAAK,GAAG,CAAC,CAAC;MACxC,OAAOA,KAAK,GAAG,CAAC;IAClB;EACF,CAAC,CAAC,CAAC;EAEH,OAAOV,SAAS;AAClB,CAAC,CAACf,IAAI,CAAC;AAEP,IAAI2B,cAAc,GAAG,aAAa,UAAUX,KAAK,EAAE;EACjD5B,SAAS,CAACuC,cAAc,EAAEX,KAAK,CAAC;EAEhC,IAAIC,MAAM,GAAG3B,YAAY,CAACqC,cAAc,CAAC;EAEzC,SAASA,cAAcA,CAACC,IAAI,EAAEC,KAAK,EAAE;IACnC,IAAIC,KAAK;IAETtC,eAAe,CAAC,IAAI,EAAEmC,cAAc,CAAC;IAErCG,KAAK,GAAGb,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEU,IAAI,EAAEC,KAAK,CAAC;IACtCC,KAAK,CAACC,IAAI,GAAG,IAAI;IACjB,OAAOD,KAAK;EACd;EAEAlC,YAAY,CAAC+B,cAAc,EAAE,CAAC;IAC5BP,GAAG,EAAE,uBAAuB;IAC5BC,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB,OAAO,CAAC,CAAC,IAAI,CAACU,IAAI,IAAI,IAAI,CAACA,IAAI,CAACC,qBAAqB;IACvD;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDZ,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIS,SAAS,GAAGT,OAAO,CAACS,SAAS;QAC7BC,GAAG,GAAGV,OAAO,CAACU,GAAG;MACrB,IAAIC,WAAW,GAAGX,OAAO,CAACW,WAAW;QACjCC,SAAS,GAAGZ,OAAO,CAACY,SAAS;MACjC,IAAI,CAACD,WAAW,IAAI,IAAI,CAACP,IAAI,KAAKlC,IAAI,CAAC2C,QAAQ,EAAE,IAAI,CAACC,KAAK,GAAG,IAAIpC,iBAAiB,CAAC,IAAI,EAAE,iEAAiE,CAAC;MAC5J,IAAIqC,MAAM,GAAGJ,WAAW,GAAGV,KAAK,GAAGW,SAAS,GAAGZ,OAAO,CAACe,MAAM;MAC7D,IAAIC,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAET,KAAK,GAAG,CAAC,CAAC;MACjD,IAAIiB,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MACpB,IAAIG,aAAa,GAAGD,EAAE,KAAK,GAAG;MAC9B,IAAIE,QAAQ,GAAG,EAAE;MACjB,IAAIC,SAAS,GAAG,IAAI;MAEpB,OAAOH,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,GAAG,EAAE;QAChC,IAAIA,EAAE,KAAK,GAAG,EAAE;UACd,IAAII,IAAI,GAAG9C,IAAI,CAAC+C,SAAS,CAACb,GAAG,EAAEM,MAAM,GAAG,CAAC,CAAC;UAE1CI,QAAQ,CAACI,IAAI,CAAC,IAAIlD,KAAK,CAAC0C,MAAM,EAAEM,IAAI,CAAC,CAAC;UACtCN,MAAM,GAAGM,IAAI;QACf,CAAC,MAAM;UACLX,WAAW,GAAG,IAAI;UAClBC,SAAS,GAAGI,MAAM,GAAG,CAAC;UACtB,IAAIS,KAAK,GAAGjD,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEE,SAAS,CAAC;UAEhD,IAAIF,GAAG,CAACe,KAAK,CAAC,KAAK,IAAI,IAAIL,QAAQ,CAACM,MAAM,KAAK,CAAC,EAAE;YAChDL,SAAS,GAAG,IAAI9B,SAAS,CAAC,CAAC;YAC3BqB,SAAS,GAAGS,SAAS,CAACtB,KAAK,CAAC;cAC1BW,GAAG,EAAEA;YACP,CAAC,EAAEE,SAAS,CAAC;UACf;UAEAI,MAAM,GAAGxC,IAAI,CAACmD,WAAW,CAACjB,GAAG,EAAEE,SAAS,CAAC;QAC3C;QAEAM,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAClB;MAEA,IAAIxC,IAAI,CAACoD,kBAAkB,CAACV,EAAE,EAAEF,MAAM,IAAIJ,SAAS,GAAGG,MAAM,CAAC,EAAE,IAAI,CAACX,IAAI,KAAKlC,IAAI,CAAC2C,QAAQ,CAAC,EAAE;QAC3F,IAAI,CAACN,IAAI,GAAGE,SAAS,CAAC;UACpBE,WAAW,EAAEA,WAAW;UACxBkB,YAAY,EAAE,KAAK;UACnBd,MAAM,EAAEA,MAAM;UACdH,SAAS,EAAEA,SAAS;UACpBkB,MAAM,EAAE;QACV,CAAC,EAAEd,MAAM,CAAC;MACZ,CAAC,MAAM,IAAIE,EAAE,IAAIN,SAAS,GAAGX,KAAK,GAAG,CAAC,EAAE;QACtCe,MAAM,GAAGJ,SAAS,GAAG,CAAC;MACxB;MAEA,IAAI,IAAI,CAACL,IAAI,EAAE;QACb,IAAIc,SAAS,EAAE;UACb;UACA;UACA;UACA,IAAIU,KAAK,GAAG/B,OAAO,CAAC8B,MAAM,CAACC,KAAK,IAAI/B,OAAO,CAAC8B,MAAM,CAACE,QAAQ;UAC3D,IAAID,KAAK,EAAEA,KAAK,CAACP,IAAI,CAACH,SAAS,CAAC;QAClC;QAEA,IAAID,QAAQ,CAACM,MAAM,EAAEO,KAAK,CAACC,SAAS,CAACV,IAAI,CAACW,KAAK,CAAC,IAAI,CAAC9B,KAAK,EAAEe,QAAQ,CAAC;QACrEJ,MAAM,GAAG,IAAI,CAACT,IAAI,CAACL,KAAK,CAACkC,GAAG;MAC9B,CAAC,MAAM;QACL,IAAIjB,aAAa,EAAE;UACjB,IAAIpD,CAAC,GAAGqD,QAAQ,CAAC,CAAC,CAAC;UACnB,IAAI,CAACf,KAAK,CAACmB,IAAI,CAACzD,CAAC,CAAC;UAClBiD,MAAM,GAAGjD,CAAC,CAACqE,GAAG;QAChB,CAAC,MAAM;UACLpB,MAAM,GAAGxC,IAAI,CAAC+C,SAAS,CAACb,GAAG,EAAET,KAAK,GAAG,CAAC,CAAC;QACzC;MACF;MAEA,IAAImC,GAAG,GAAG,IAAI,CAAC7B,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC8B,UAAU,CAACD,GAAG,GAAGpB,MAAM;MACvD,IAAI,CAACqB,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,EAAEmC,GAAG,CAAC;MACvC,OAAOpB,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,eAAe;IACpBE,KAAK,EAAE,SAASwC,aAAaA,CAACC,EAAE,EAAEvB,MAAM,EAAE;MACxCA,MAAM,GAAGpC,IAAI,CAACE,eAAe,CAACqB,cAAc,CAAC+B,SAAS,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,CAACxC,IAAI,CAAC,IAAI,EAAE6C,EAAE,EAAEvB,MAAM,CAAC;MACtG,OAAO,IAAI,CAACT,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC+B,aAAa,CAACC,EAAE,EAAEvB,MAAM,CAAC,GAAGA,MAAM;IACjE;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,UAAU;IACfE,KAAK,EAAE,SAAS0C,QAAQA,CAAA,EAAG;MACzB,IAAI9B,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;QACtBH,IAAI,GAAG,IAAI,CAACA,IAAI;QAChBL,KAAK,GAAG,IAAI,CAACA,KAAK;QAClBJ,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIA,KAAK,IAAI,IAAI,EAAE,OAAOA,KAAK;MAC/B,IAAI2C,GAAG,GAAGlC,IAAI,GAAGG,GAAG,CAACgC,KAAK,CAACxC,KAAK,CAACD,KAAK,EAAEM,IAAI,CAACL,KAAK,CAACD,KAAK,CAAC,GAAG0C,MAAM,CAACpC,IAAI,CAAC,GAAGG,GAAG,CAACgC,KAAK,CAACxC,KAAK,CAACD,KAAK,EAAEC,KAAK,CAACkC,GAAG,CAAC;MAC5G,OAAO5D,IAAI,CAACoE,mBAAmB,CAAClC,GAAG,EAAER,KAAK,CAACkC,GAAG,EAAEK,GAAG,CAAC;IACtD;EACF,CAAC,CAAC,CAAC;EAEH,OAAOtC,cAAc;AACvB,CAAC,CAAC3B,IAAI,CAAC;AAEP,IAAIqE,OAAO,GAAG,aAAa,UAAUrD,KAAK,EAAE;EAC1C5B,SAAS,CAACiF,OAAO,EAAErD,KAAK,CAAC;EAEzB,IAAIC,MAAM,GAAG3B,YAAY,CAAC+E,OAAO,CAAC;EAElC,SAASA,OAAOA,CAAA,EAAG;IACjB7E,eAAe,CAAC,IAAI,EAAE6E,OAAO,CAAC;IAE9B,OAAOpD,MAAM,CAACC,IAAI,CAAC,IAAI,EAAExB,IAAI,CAAC4E,OAAO,CAAC;EACxC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAGE1E,YAAY,CAACyE,OAAO,EAAE,CAAC;IACrBjD,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIgB,MAAM,GAAG,IAAI,CAAC+B,YAAY,CAAC9C,KAAK,CAAC;MACrC,IAAI,CAACC,KAAK,GAAG,IAAI5B,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;MACrC,OAAOA,MAAM;IACf;EACF,CAAC,CAAC,CAAC;EAEH,OAAO6B,OAAO;AAChB,CAAC,CAACrE,IAAI,CAAC;AAEP,SAASwE,yBAAyBA,CAACzC,IAAI,EAAE;EACvC,IAAI0C,KAAK,GAAG1C,IAAI;EAEhB,OAAO0C,KAAK,YAAY9C,cAAc,EAAE;IACtC8C,KAAK,GAAGA,KAAK,CAAC1C,IAAI;EACpB;EAEA,IAAI,EAAE0C,KAAK,YAAYC,UAAU,CAAC,EAAE,OAAO,IAAI;EAC/C,IAAIC,GAAG,GAAGF,KAAK,CAAClB,KAAK,CAACL,MAAM;EAC5B,IAAI0B,EAAE,GAAG,CAAC,CAAC;EAEX,KAAK,IAAIC,CAAC,GAAGF,GAAG,GAAG,CAAC,EAAEE,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;IACjC,IAAIC,CAAC,GAAGL,KAAK,CAAClB,KAAK,CAACsB,CAAC,CAAC;IAEtB,IAAIC,CAAC,CAAClD,IAAI,KAAKlC,IAAI,CAAC4E,OAAO,EAAE;MAC3B;MACA,IAAIS,UAAU,GAAGD,CAAC,CAACtD,OAAO;QACtBe,MAAM,GAAGwC,UAAU,CAACxC,MAAM;QAC1BH,SAAS,GAAG2C,UAAU,CAAC3C,SAAS;MACpC,IAAIG,MAAM,GAAG,CAAC,IAAIuC,CAAC,CAACpD,KAAK,CAACD,KAAK,IAAIW,SAAS,GAAGG,MAAM,EAAE;MACvDqC,EAAE,GAAGC,CAAC;IACR,CAAC,MAAM,IAAIC,CAAC,CAAClD,IAAI,KAAKlC,IAAI,CAACyB,UAAU,EAAEyD,EAAE,GAAGC,CAAC,CAAC,KAAK;EACrD;EAEA,IAAID,EAAE,KAAK,CAAC,CAAC,EAAE,OAAO,IAAI;EAC1B,IAAII,EAAE,GAAGP,KAAK,CAAClB,KAAK,CAAC0B,MAAM,CAACL,EAAE,EAAED,GAAG,GAAGC,EAAE,CAAC;EACzC,IAAIM,OAAO,GAAGF,EAAE,CAAC,CAAC,CAAC,CAACtD,KAAK,CAACD,KAAK;EAE/B,OAAO,IAAI,EAAE;IACXgD,KAAK,CAAC/C,KAAK,CAACkC,GAAG,GAAGsB,OAAO;IACzB,IAAIT,KAAK,CAACZ,UAAU,IAAIY,KAAK,CAACZ,UAAU,CAACD,GAAG,GAAGsB,OAAO,EAAET,KAAK,CAACZ,UAAU,CAACD,GAAG,GAAGsB,OAAO;IACtF,IAAIT,KAAK,KAAK1C,IAAI,EAAE;IACpB0C,KAAK,GAAGA,KAAK,CAACjD,OAAO,CAAC8B,MAAM;EAC9B;EAEA,OAAO0B,EAAE;AACX;AACA,IAAIN,UAAU,GAAG,aAAa,UAAU1D,KAAK,EAAE;EAC7C5B,SAAS,CAACsF,UAAU,EAAE1D,KAAK,CAAC;EAE5B,IAAIC,MAAM,GAAG3B,YAAY,CAACoF,UAAU,CAAC;EAErC,SAASA,UAAUA,CAACS,SAAS,EAAE;IAC7B,IAAIrD,KAAK;IAETtC,eAAe,CAAC,IAAI,EAAEkF,UAAU,CAAC;IAEjC5C,KAAK,GAAGb,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEiE,SAAS,CAACvD,IAAI,KAAKlC,IAAI,CAAC2C,QAAQ,GAAG3C,IAAI,CAAC0F,GAAG,GAAG1F,IAAI,CAAC2F,GAAG,CAAC;IAEjF,KAAK,IAAIR,CAAC,GAAGM,SAAS,CAACtD,KAAK,CAACqB,MAAM,GAAG,CAAC,EAAE2B,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MACpD,IAAIM,SAAS,CAACtD,KAAK,CAACgD,CAAC,CAAC,CAACpD,KAAK,GAAG0D,SAAS,CAAC3D,OAAO,CAACY,SAAS,EAAE;QAC1D;QACAN,KAAK,CAACD,KAAK,GAAGsD,SAAS,CAACtD,KAAK,CAACqC,KAAK,CAAC,CAAC,EAAEW,CAAC,GAAG,CAAC,CAAC;QAC7CM,SAAS,CAACtD,KAAK,GAAGsD,SAAS,CAACtD,KAAK,CAACqC,KAAK,CAACW,CAAC,GAAG,CAAC,CAAC;QAC9C,IAAIS,SAAS,GAAGH,SAAS,CAACtD,KAAK,CAAC,CAAC,CAAC,IAAIsD,SAAS,CAACtB,UAAU;QAC1DsB,SAAS,CAACzD,KAAK,CAACD,KAAK,GAAG6D,SAAS,CAAC7D,KAAK;QACvC;MACF;IACF;IAEAK,KAAK,CAACyB,KAAK,GAAG,CAAC4B,SAAS,CAAC;IACzB,IAAII,EAAE,GAAGf,yBAAyB,CAACW,SAAS,CAAC;IAC7C,IAAII,EAAE,EAAE9B,KAAK,CAACC,SAAS,CAACV,IAAI,CAACW,KAAK,CAAC7B,KAAK,CAACyB,KAAK,EAAEgC,EAAE,CAAC;IACnD,OAAOzD,KAAK;EACd;EAEAlC,YAAY,CAAC8E,UAAU,EAAE,CAAC;IACxBtD,GAAG,EAAE,uBAAuB;IAC5BC,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB,OAAO,IAAI,CAACkC,KAAK,CAACL,MAAM,GAAG,CAAC;IAC9B;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD9B,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIS,SAAS,GAAGT,OAAO,CAACS,SAAS;QAC7BC,GAAG,GAAGV,OAAO,CAACU,GAAG,CAAC,CAAC;MACvB;;MAEA,IAAIE,SAAS,GAAGpC,IAAI,CAACwF,WAAW,CAACtD,GAAG,EAAET,KAAK,CAAC;MAC5C,IAAI0D,SAAS,GAAG,IAAI,CAAC5B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MAC/B;;MAEA4B,SAAS,CAAC3D,OAAO,CAAC8B,MAAM,GAAG,IAAI;MAC/B,IAAI,CAACO,UAAU,GAAG/D,KAAK,CAAC2F,IAAI,CAACN,SAAS,CAACtB,UAAU,CAAC;MAClD,IAAItB,MAAM,GAAG4C,SAAS,CAACzD,KAAK,CAACD,KAAK,GAAG0D,SAAS,CAAC3D,OAAO,CAACY,SAAS;MAChE,IAAII,MAAM,GAAGf,KAAK;MAClBe,MAAM,GAAGxC,IAAI,CAAC0F,eAAe,CAACxD,GAAG,EAAEM,MAAM,CAAC;MAC1C,IAAIE,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MACpB,IAAIL,WAAW,GAAGnC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEE,SAAS,CAAC,KAAKI,MAAM;MACjE,IAAImD,yBAAyB,GAAG,KAAK;MAErC,OAAOjD,EAAE,EAAE;QACT,OAAOA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,GAAG,EAAE;UAChC,IAAIP,WAAW,IAAIO,EAAE,KAAK,IAAI,IAAI,CAACiD,yBAAyB,EAAE;YAC5D,IAAI9C,SAAS,GAAG,IAAI9B,SAAS,CAAC,CAAC;YAC/ByB,MAAM,GAAGK,SAAS,CAACtB,KAAK,CAAC;cACvBW,GAAG,EAAEA;YACP,CAAC,EAAEM,MAAM,CAAC;YACV,IAAI,CAACqB,UAAU,CAACD,GAAG,GAAGpB,MAAM;YAE5B,IAAIA,MAAM,IAAIN,GAAG,CAACgB,MAAM,EAAE;cACxBR,EAAE,GAAG,IAAI;cACT;YACF;YAEA,IAAI,CAACa,KAAK,CAACP,IAAI,CAACH,SAAS,CAAC;YAC1BL,MAAM,IAAI,CAAC,CAAC,CAAC;UACf,CAAC,MAAM,IAAIE,EAAE,KAAK,GAAG,EAAE;YACrB,IAAIF,MAAM,GAAGJ,SAAS,GAAGG,MAAM,IAAI,CAACmC,UAAU,CAACkB,oBAAoB,CAAC1D,GAAG,EAAEM,MAAM,EAAED,MAAM,CAAC,EAAE;cACxF,OAAOC,MAAM;YACf;YAEA,IAAIqD,OAAO,GAAG,IAAIxB,OAAO,CAAC,CAAC;YAC3B7B,MAAM,GAAGqD,OAAO,CAACtE,KAAK,CAAC;cACrBgB,MAAM,EAAEA,MAAM;cACdH,SAAS,EAAEA,SAAS;cACpBF,GAAG,EAAEA;YACP,CAAC,EAAEM,MAAM,CAAC;YACV,IAAI,CAACe,KAAK,CAACP,IAAI,CAAC6C,OAAO,CAAC;YACxB,IAAI,CAAChC,UAAU,CAACD,GAAG,GAAGpB,MAAM;YAE5B,IAAIA,MAAM,IAAIN,GAAG,CAACgB,MAAM,EAAE;cACxBR,EAAE,GAAG,IAAI;cACT;YACF;UACF;UAEAN,SAAS,GAAGI,MAAM,GAAG,CAAC;UACtBA,MAAM,GAAGxC,IAAI,CAACmD,WAAW,CAACjB,GAAG,EAAEE,SAAS,CAAC;UAEzC,IAAIpC,IAAI,CAAC8F,OAAO,CAAC5D,GAAG,EAAEM,MAAM,CAAC,EAAE;YAC7B,IAAIS,KAAK,GAAGjD,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;YAC7C,IAAIuD,IAAI,GAAG7D,GAAG,CAACe,KAAK,CAAC;YAErB,IAAI,CAAC8C,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,GAAG,EAAE;cAC1CvD,MAAM,GAAGS,KAAK;YAChB;UACF;UAEAP,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;UAChBL,WAAW,GAAG,IAAI;QACpB;QAEA,IAAI,CAACO,EAAE,EAAE;UACP;QACF;QAEA,IAAIF,MAAM,KAAKJ,SAAS,GAAGG,MAAM,KAAKJ,WAAW,IAAIO,EAAE,KAAK,GAAG,CAAC,EAAE;UAChE,IAAIF,MAAM,GAAGJ,SAAS,GAAGG,MAAM,EAAE;YAC/B,IAAIH,SAAS,GAAGX,KAAK,EAAEe,MAAM,GAAGJ,SAAS;YACzC;UACF,CAAC,MAAM,IAAI,CAAC,IAAI,CAACE,KAAK,EAAE;YACtB,IAAI0D,GAAG,GAAG,oDAAoD;YAC9D,IAAI,CAAC1D,KAAK,GAAG,IAAI9B,eAAe,CAAC,IAAI,EAAEwF,GAAG,CAAC;UAC7C;QACF;QAEA,IAAIb,SAAS,CAACvD,IAAI,KAAKlC,IAAI,CAAC2C,QAAQ,EAAE;UACpC,IAAIK,EAAE,KAAK,GAAG,EAAE;YACd,IAAIN,SAAS,GAAGX,KAAK,EAAEe,MAAM,GAAGJ,SAAS;YACzC;UACF;QACF,CAAC,MAAM,IAAIM,EAAE,KAAK,GAAG,IAAI,CAAC,IAAI,CAACJ,KAAK,EAAE;UACpC;UACA,IAAI2D,KAAK,GAAG/D,GAAG,CAACM,MAAM,GAAG,CAAC,CAAC;UAE3B,IAAI,CAACyD,KAAK,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,GAAG,EAAE;YAC/D,IAAIC,IAAI,GAAG,sDAAsD;YACjE,IAAI,CAAC5D,KAAK,GAAG,IAAI9B,eAAe,CAAC,IAAI,EAAE0F,IAAI,CAAC;UAC9C;QACF;QAEA,IAAInE,IAAI,GAAGE,SAAS,CAAC;UACnBE,WAAW,EAAEA,WAAW;UACxBkB,YAAY,EAAE,IAAI;UAClBd,MAAM,EAAEA,MAAM;UACdH,SAAS,EAAEA,SAAS;UACpBkB,MAAM,EAAE;QACV,CAAC,EAAEd,MAAM,CAAC;QACV,IAAI,CAACT,IAAI,EAAE,OAAOS,MAAM,CAAC,CAAC;;QAE1B,IAAI,CAACe,KAAK,CAACP,IAAI,CAACjB,IAAI,CAAC;QACrB,IAAI,CAAC8B,UAAU,CAACD,GAAG,GAAG7B,IAAI,CAAC8B,UAAU,CAACD,GAAG;QACzCpB,MAAM,GAAGxC,IAAI,CAAC0F,eAAe,CAACxD,GAAG,EAAEH,IAAI,CAACL,KAAK,CAACkC,GAAG,CAAC;QAClDlB,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;QAChBL,WAAW,GAAG,KAAK;QACnBwD,yBAAyB,GAAG5D,IAAI,CAACC,qBAAqB,CAAC,CAAC;QACxD;QACA;;QAEA,IAAIU,EAAE,EAAE;UACN,IAAIyD,EAAE,GAAG3D,MAAM,GAAG,CAAC;UACnB,IAAI4D,IAAI,GAAGlE,GAAG,CAACiE,EAAE,CAAC;UAElB,OAAOC,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EAAE;YACpCA,IAAI,GAAGlE,GAAG,CAAC,EAAEiE,EAAE,CAAC;UAClB;UAEA,IAAIC,IAAI,KAAK,IAAI,EAAE;YACjBhE,SAAS,GAAG+D,EAAE,GAAG,CAAC;YAClBhE,WAAW,GAAG,IAAI;UACpB;QACF;QAEA,IAAIoD,EAAE,GAAGf,yBAAyB,CAACzC,IAAI,CAAC;QACxC,IAAIwD,EAAE,EAAE9B,KAAK,CAACC,SAAS,CAACV,IAAI,CAACW,KAAK,CAAC,IAAI,CAACJ,KAAK,EAAEgC,EAAE,CAAC;MACpD;MAEA,OAAO/C,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,eAAe;IACpBE,KAAK,EAAE,SAASwC,aAAaA,CAACC,EAAE,EAAEvB,MAAM,EAAE;MACxCA,MAAM,GAAGpC,IAAI,CAACE,eAAe,CAACoE,UAAU,CAAChB,SAAS,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,CAACxC,IAAI,CAAC,IAAI,EAAE6C,EAAE,EAAEvB,MAAM,CAAC;MAClG,IAAI,CAACe,KAAK,CAAC8C,OAAO,CAAC,UAAUtE,IAAI,EAAE;QACjCS,MAAM,GAAGT,IAAI,CAAC+B,aAAa,CAACC,EAAE,EAAEvB,MAAM,CAAC;MACzC,CAAC,CAAC;MACF,OAAOA,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,UAAU;IACfE,KAAK,EAAE,SAAS0C,QAAQA,CAAA,EAAG;MACzB,IAAI9B,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;QACtBqB,KAAK,GAAG,IAAI,CAACA,KAAK;QAClB7B,KAAK,GAAG,IAAI,CAACA,KAAK;QAClBJ,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIA,KAAK,IAAI,IAAI,EAAE,OAAOA,KAAK;MAC/B,IAAI2C,GAAG,GAAG/B,GAAG,CAACgC,KAAK,CAACxC,KAAK,CAACD,KAAK,EAAE8B,KAAK,CAAC,CAAC,CAAC,CAAC7B,KAAK,CAACD,KAAK,CAAC,GAAG0C,MAAM,CAACZ,KAAK,CAAC,CAAC,CAAC,CAAC;MAEzE,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,KAAK,CAACL,MAAM,EAAE,EAAE2B,CAAC,EAAE;QACrC,IAAIyB,IAAI,GAAG/C,KAAK,CAACsB,CAAC,CAAC;QACnB,IAAI0B,aAAa,GAAGD,IAAI,CAAC9E,OAAO;UAC5BW,WAAW,GAAGoE,aAAa,CAACpE,WAAW;UACvCI,MAAM,GAAGgE,aAAa,CAAChE,MAAM;QACjC,IAAIJ,WAAW,EAAE,KAAK,IAAIqE,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGjE,MAAM,EAAE,EAAEiE,EAAE,EAAE;UACnDvC,GAAG,IAAI,GAAG;QACZ;QACAA,GAAG,IAAIE,MAAM,CAACmC,IAAI,CAAC;MACrB;MAEA,OAAOtG,IAAI,CAACoE,mBAAmB,CAAClC,GAAG,EAAER,KAAK,CAACkC,GAAG,EAAEK,GAAG,CAAC;IACtD;EACF,CAAC,CAAC,EAAE,CAAC;IACH7C,GAAG,EAAE,sBAAsB;IAC3BE,KAAK,EAAE,SAASsE,oBAAoBA,CAAC1D,GAAG,EAAEM,MAAM,EAAED,MAAM,EAAE;MACxD,IAAIH,SAAS,GAAGpC,IAAI,CAAC+C,SAAS,CAACb,GAAG,EAAEM,MAAM,CAAC,GAAG,CAAC;MAC/CA,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEE,SAAS,CAAC;MAC7C,IAAIM,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MACpB,IAAI,CAACE,EAAE,EAAE,OAAO,KAAK;MACrB,IAAIF,MAAM,IAAIJ,SAAS,GAAGG,MAAM,EAAE,OAAO,IAAI;MAC7C,IAAIG,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,IAAI,EAAE,OAAO,KAAK;MAC3C,OAAOgC,UAAU,CAACkB,oBAAoB,CAAC1D,GAAG,EAAEM,MAAM,EAAED,MAAM,CAAC;IAC7D;EACF,CAAC,CAAC,CAAC;EAEH,OAAOmC,UAAU;AACnB,CAAC,CAAC1E,IAAI,CAAC;AAEP,IAAIyG,SAAS,GAAG,aAAa,UAAUzF,KAAK,EAAE;EAC5C5B,SAAS,CAACqH,SAAS,EAAEzF,KAAK,CAAC;EAE3B,IAAIC,MAAM,GAAG3B,YAAY,CAACmH,SAAS,CAAC;EAEpC,SAASA,SAASA,CAAA,EAAG;IACnB,IAAI3E,KAAK;IAETtC,eAAe,CAAC,IAAI,EAAEiH,SAAS,CAAC;IAEhC3E,KAAK,GAAGb,MAAM,CAACC,IAAI,CAAC,IAAI,EAAExB,IAAI,CAACgH,SAAS,CAAC;IACzC5E,KAAK,CAAC6E,IAAI,GAAG,IAAI;IACjB,OAAO7E,KAAK;EACd;EAEAlC,YAAY,CAAC6G,SAAS,EAAE,CAAC;IACvBrF,GAAG,EAAE,YAAY;IACjBC,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB,IAAIuF,GAAG,GAAG,IAAI,CAACC,QAAQ;MACvB,OAAOD,GAAG,GAAGA,GAAG,CAACE,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE;IAC9C;EACF,CAAC,EAAE;IACD3F,GAAG,EAAE,WAAW;IAChBE,KAAK,EAAE,SAAS0F,SAASA,CAACvF,KAAK,EAAE;MAC/B,IAAIS,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;MAC1B,IAAIM,MAAM,GAAGf,KAAK;MAClB,IAAIiB,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAEpB,OAAOE,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,GAAG,EAAE;QACrDA,EAAE,GAAGR,GAAG,CAACM,MAAM,IAAI,CAAC,CAAC;MACvB;MAEA,IAAI,CAACmE,IAAI,GAAGzE,GAAG,CAACgC,KAAK,CAACzC,KAAK,EAAEe,MAAM,CAAC;MACpC,OAAOA,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,iBAAiB;IACtBE,KAAK,EAAE,SAAS2F,eAAeA,CAACxF,KAAK,EAAE;MACrC,IAAIS,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;MAC1B,IAAIM,MAAM,GAAGf,KAAK;MAClB,IAAIiB,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAEpB,OAAOE,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,GAAG,EAAE;QACtCA,EAAE,GAAGR,GAAG,CAACM,MAAM,IAAI,CAAC,CAAC;MACvB;MAEA,IAAI,CAACqB,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;MAC1C,OAAOA,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIgB,MAAM,GAAG,IAAI,CAACwE,SAAS,CAACvF,KAAK,GAAG,CAAC,CAAC;MACtCe,MAAM,GAAG,IAAI,CAACyE,eAAe,CAACzE,MAAM,CAAC;MACrCA,MAAM,GAAG,IAAI,CAAC+B,YAAY,CAAC/B,MAAM,CAAC;MAClC,IAAI,CAACd,KAAK,GAAG,IAAI5B,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;MACrC,OAAOA,MAAM;IACf;EACF,CAAC,CAAC,CAAC;EAEH,OAAOiE,SAAS;AAClB,CAAC,CAACzG,IAAI,CAAC;AAEP,IAAIkH,QAAQ,GAAG,aAAa,UAAUlG,KAAK,EAAE;EAC3C5B,SAAS,CAAC8H,QAAQ,EAAElG,KAAK,CAAC;EAE1B,IAAIC,MAAM,GAAG3B,YAAY,CAAC4H,QAAQ,CAAC;EAEnC,SAASA,QAAQA,CAAA,EAAG;IAClB,IAAIpF,KAAK;IAETtC,eAAe,CAAC,IAAI,EAAE0H,QAAQ,CAAC;IAE/BpF,KAAK,GAAGb,MAAM,CAACC,IAAI,CAAC,IAAI,EAAExB,IAAI,CAACyH,QAAQ,CAAC;IACxCrF,KAAK,CAACsF,UAAU,GAAG,IAAI;IACvBtF,KAAK,CAAC0B,QAAQ,GAAG,IAAI;IACrB1B,KAAK,CAACuF,mBAAmB,GAAG,IAAI;IAChCvF,KAAK,CAACwF,iBAAiB,GAAG,IAAI;IAC9B,OAAOxF,KAAK;EACd;EAEAlC,YAAY,CAACsH,QAAQ,EAAE,CAAC;IACtB9F,GAAG,EAAE,iBAAiB;IACtBE,KAAK,EAAE,SAASiG,eAAeA,CAAC9F,KAAK,EAAE;MACrC,IAAIS,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;MAC1B,IAAI,CAACkF,UAAU,GAAG,EAAE;MACpB,IAAIjF,WAAW,GAAG,IAAI;MACtB,IAAIqF,aAAa,GAAG,KAAK;MACzB,IAAIhF,MAAM,GAAGf,KAAK;MAElB,OAAO,CAACzB,IAAI,CAACyH,kBAAkB,CAACvF,GAAG,EAAEM,MAAM,EAAE9B,IAAI,CAACgH,cAAc,CAAC,EAAE;QACjElF,MAAM,GAAG0E,QAAQ,CAACS,0BAA0B,CAACzF,GAAG,EAAEM,MAAM,CAAC;QAEzD,QAAQN,GAAG,CAACM,MAAM,CAAC;UACjB,KAAK,IAAI;YACP,IAAIL,WAAW,EAAE;cACf,IAAIU,SAAS,GAAG,IAAI9B,SAAS,CAAC,CAAC;cAC/ByB,MAAM,GAAGK,SAAS,CAACtB,KAAK,CAAC;gBACvBW,GAAG,EAAEA;cACP,CAAC,EAAEM,MAAM,CAAC;cAEV,IAAIA,MAAM,GAAGN,GAAG,CAACgB,MAAM,EAAE;gBACvB,IAAI,CAACkE,UAAU,CAACpE,IAAI,CAACH,SAAS,CAAC;cACjC;YACF,CAAC,MAAM;cACLL,MAAM,IAAI,CAAC;cACXL,WAAW,GAAG,IAAI;YACpB;YAEA;UAEF,KAAK,GAAG;YACN;cACE,IAAI0D,OAAO,GAAG,IAAIxB,OAAO,CAAC,CAAC;cAC3B7B,MAAM,GAAGqD,OAAO,CAACtE,KAAK,CAAC;gBACrBW,GAAG,EAAEA;cACP,CAAC,EAAEM,MAAM,CAAC;cACV,IAAI,CAAC4E,UAAU,CAACpE,IAAI,CAAC6C,OAAO,CAAC;cAC7B1D,WAAW,GAAG,KAAK;YACrB;YACA;UAEF,KAAK,GAAG;YACN;cACE,IAAIyF,SAAS,GAAG,IAAInB,SAAS,CAAC,CAAC;cAC/BjE,MAAM,GAAGoF,SAAS,CAACrG,KAAK,CAAC;gBACvB+B,MAAM,EAAE,IAAI;gBACZpB,GAAG,EAAEA;cACP,CAAC,EAAEM,MAAM,CAAC;cACV,IAAI,CAAC4E,UAAU,CAACpE,IAAI,CAAC4E,SAAS,CAAC;cAC/BJ,aAAa,GAAG,IAAI;cACpBrF,WAAW,GAAG,KAAK;YACrB;YACA;UAEF;YACE,IAAIqF,aAAa,EAAE;cACjB,IAAI,CAAClF,KAAK,GAAG,IAAIpC,iBAAiB,CAAC,IAAI,EAAE,uCAAuC,CAAC;YACnF,CAAC,MAAM,IAAI,IAAI,CAACkH,UAAU,CAAClE,MAAM,GAAG,CAAC,EAAE;cACrC,IAAI,CAACM,QAAQ,GAAG,IAAI,CAAC4D,UAAU;cAC/B,IAAI,CAACA,UAAU,GAAG,EAAE;YACtB;YAEA,OAAO5E,MAAM;QACjB;MACF;MAEA,IAAIN,GAAG,CAACM,MAAM,CAAC,EAAE;QACf,IAAI,CAAC6E,mBAAmB,GAAG,IAAIvH,KAAK,CAAC0C,MAAM,EAAEA,MAAM,GAAG,CAAC,CAAC;QACxD,OAAOA,MAAM,GAAG,CAAC;MACnB;MAEA,IAAIgF,aAAa,EAAE;QACjB,IAAI,CAAClF,KAAK,GAAG,IAAIpC,iBAAiB,CAAC,IAAI,EAAE,uCAAuC,CAAC;MACnF,CAAC,MAAM,IAAI,IAAI,CAACkH,UAAU,CAAClE,MAAM,GAAG,CAAC,EAAE;QACrC,IAAI,CAACM,QAAQ,GAAG,IAAI,CAAC4D,UAAU;QAC/B,IAAI,CAACA,UAAU,GAAG,EAAE;MACtB;MAEA,OAAO5E,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,eAAe;IACpBE,KAAK,EAAE,SAASuG,aAAaA,CAACpG,KAAK,EAAE;MACnC,IAAIqG,aAAa,GAAG,IAAI,CAACtG,OAAO;QAC5BS,SAAS,GAAG6F,aAAa,CAAC7F,SAAS;QACnCC,GAAG,GAAG4F,aAAa,CAAC5F,GAAG;MAC3B,IAAI,CAAC,IAAI,CAACsB,QAAQ,EAAE,IAAI,CAACA,QAAQ,GAAG,EAAE;MACtC,IAAIpB,SAAS,GAAGX,KAAK;MAErB,OAAOS,GAAG,CAACE,SAAS,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;QACjCA,SAAS,IAAI,CAAC;MAChB;MAEA,IAAII,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAET,KAAK,CAAC;MAC7C,IAAIU,WAAW,GAAGC,SAAS,KAAKX,KAAK;MACrC,IAAI,CAACoC,UAAU,GAAG,IAAI/D,KAAK,CAAC0C,MAAM,CAAC;MAEnC,OAAO,CAACxC,IAAI,CAACyH,kBAAkB,CAACvF,GAAG,EAAEM,MAAM,EAAE9B,IAAI,CAACqH,YAAY,CAAC,EAAE;QAC/D,QAAQ7F,GAAG,CAACM,MAAM,CAAC;UACjB,KAAK,IAAI;YACP,IAAIL,WAAW,EAAE;cACf,IAAIU,SAAS,GAAG,IAAI9B,SAAS,CAAC,CAAC;cAC/ByB,MAAM,GAAGK,SAAS,CAACtB,KAAK,CAAC;gBACvBW,GAAG,EAAEA;cACP,CAAC,EAAEM,MAAM,CAAC;cAEV,IAAIA,MAAM,GAAGN,GAAG,CAACgB,MAAM,EAAE;gBACvB,IAAI,CAACM,QAAQ,CAACR,IAAI,CAACH,SAAS,CAAC;cAC/B;YACF,CAAC,MAAM;cACLL,MAAM,IAAI,CAAC;cACXL,WAAW,GAAG,IAAI;YACpB;YAEAC,SAAS,GAAGI,MAAM;YAClB;UAEF,KAAK,GAAG;YACN;cACE,IAAIqD,OAAO,GAAG,IAAIxB,OAAO,CAAC,CAAC;cAC3B7B,MAAM,GAAGqD,OAAO,CAACtE,KAAK,CAAC;gBACrBW,GAAG,EAAEA;cACP,CAAC,EAAEM,MAAM,CAAC;cACV,IAAI,CAACgB,QAAQ,CAACR,IAAI,CAAC6C,OAAO,CAAC;cAC3B1D,WAAW,GAAG,KAAK;YACrB;YACA;UAEF;YACE;cACE,IAAI6F,IAAI,GAAGhI,IAAI,CAACmD,WAAW,CAACjB,GAAG,EAAEM,MAAM,CAAC;cACxC,IAAIhB,OAAO,GAAG;gBACZW,WAAW,EAAEA,WAAW;gBACxBI,MAAM,EAAE,CAAC,CAAC;gBACV0F,MAAM,EAAE,KAAK;gBACb5E,YAAY,EAAE,KAAK;gBACnBjB,SAAS,EAAEA,SAAS;gBACpBkB,MAAM,EAAE;cACV,CAAC;cACD,IAAIvB,IAAI,GAAGE,SAAS,CAACT,OAAO,EAAEwG,IAAI,CAAC;cACnC,IAAI,CAACjG,IAAI,EAAE,OAAO,IAAI,CAAC8B,UAAU,CAACD,GAAG,GAAGoE,IAAI,CAAC,CAAC;;cAE9C,IAAI,CAACxE,QAAQ,CAACR,IAAI,CAACjB,IAAI,CAAC;cACxBS,MAAM,GAAGT,IAAI,CAACL,KAAK,CAACkC,GAAG;cACvBzB,WAAW,GAAG,KAAK;cACnB,IAAIoD,EAAE,GAAGf,yBAAyB,CAACzC,IAAI,CAAC;cACxC,IAAIwD,EAAE,EAAE9B,KAAK,CAACC,SAAS,CAACV,IAAI,CAACW,KAAK,CAAC,IAAI,CAACH,QAAQ,EAAE+B,EAAE,CAAC;YACvD;QACJ;QAEA/C,MAAM,GAAG0E,QAAQ,CAACS,0BAA0B,CAACzF,GAAG,EAAEM,MAAM,CAAC;MAC3D;MAEA,IAAI,CAACqB,UAAU,CAACD,GAAG,GAAGpB,MAAM;MAE5B,IAAIN,GAAG,CAACM,MAAM,CAAC,EAAE;QACf,IAAI,CAAC8E,iBAAiB,GAAG,IAAIxH,KAAK,CAAC0C,MAAM,EAAEA,MAAM,GAAG,CAAC,CAAC;QACtDA,MAAM,IAAI,CAAC;QAEX,IAAIN,GAAG,CAACM,MAAM,CAAC,EAAE;UACfA,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;UAE1C,IAAIN,GAAG,CAACM,MAAM,CAAC,KAAK,GAAG,EAAE;YACvB,IAAI0F,QAAQ,GAAG,IAAI7D,OAAO,CAAC,CAAC;YAE5B7B,MAAM,GAAG0F,QAAQ,CAAC3G,KAAK,CAAC;cACtBW,GAAG,EAAEA;YACP,CAAC,EAAEM,MAAM,CAAC;YACV,IAAI,CAACgB,QAAQ,CAACR,IAAI,CAACkF,QAAQ,CAAC;UAC9B;UAEA,QAAQhG,GAAG,CAACM,MAAM,CAAC;YACjB,KAAK,IAAI;cACPA,MAAM,IAAI,CAAC;cACX;YAEF,KAAK2F,SAAS;cACZ;YAEF;cACE,IAAI,CAAC7F,KAAK,GAAG,IAAI9B,eAAe,CAAC,IAAI,EAAE,2DAA2D,CAAC;UACvG;QACF;MACF;MAEA,OAAOgC,MAAM;IACf;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDpB,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpCD,OAAO,CAAC4G,IAAI,GAAG,IAAI;MACnB,IAAI,CAAC5G,OAAO,GAAGA,OAAO;MACtB,IAAIU,GAAG,GAAGV,OAAO,CAACU,GAAG;MACrB,IAAIM,MAAM,GAAGN,GAAG,CAACmG,UAAU,CAAC5G,KAAK,CAAC,KAAK,MAAM,GAAGA,KAAK,GAAG,CAAC,GAAGA,KAAK,CAAC,CAAC;;MAEnEe,MAAM,GAAG,IAAI,CAAC+E,eAAe,CAAC/E,MAAM,CAAC;MACrCA,MAAM,GAAG,IAAI,CAACqF,aAAa,CAACrF,MAAM,CAAC;MACnC,OAAOA,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,eAAe;IACpBE,KAAK,EAAE,SAASwC,aAAaA,CAACC,EAAE,EAAEvB,MAAM,EAAE;MACxCA,MAAM,GAAGpC,IAAI,CAACE,eAAe,CAAC4G,QAAQ,CAACxD,SAAS,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,CAACxC,IAAI,CAAC,IAAI,EAAE6C,EAAE,EAAEvB,MAAM,CAAC;MAChG,IAAI,CAAC4E,UAAU,CAACf,OAAO,CAAC,UAAUtE,IAAI,EAAE;QACtCS,MAAM,GAAGT,IAAI,CAAC+B,aAAa,CAACC,EAAE,EAAEvB,MAAM,CAAC;MACzC,CAAC,CAAC;MACF,IAAI,IAAI,CAAC6E,mBAAmB,EAAE7E,MAAM,GAAG,IAAI,CAAC6E,mBAAmB,CAACiB,YAAY,CAACvE,EAAE,EAAEvB,MAAM,CAAC;MACxF,IAAI,CAACgB,QAAQ,CAAC6C,OAAO,CAAC,UAAUtE,IAAI,EAAE;QACpCS,MAAM,GAAGT,IAAI,CAAC+B,aAAa,CAACC,EAAE,EAAEvB,MAAM,CAAC;MACzC,CAAC,CAAC;MACF,IAAI,IAAI,CAAC8E,iBAAiB,EAAE9E,MAAM,GAAG,IAAI,CAAC8E,iBAAiB,CAACgB,YAAY,CAACvE,EAAE,EAAEvB,MAAM,CAAC;MACpF,OAAOA,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,UAAU;IACfE,KAAK,EAAE,SAAS0C,QAAQA,CAAA,EAAG;MACzB,IAAIR,QAAQ,GAAG,IAAI,CAACA,QAAQ;QACxB4D,UAAU,GAAG,IAAI,CAACA,UAAU;QAC5B9F,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIA,KAAK,IAAI,IAAI,EAAE,OAAOA,KAAK;MAC/B,IAAI2C,GAAG,GAAGmD,UAAU,CAACmB,IAAI,CAAC,EAAE,CAAC;MAE7B,IAAI/E,QAAQ,CAACN,MAAM,GAAG,CAAC,EAAE;QACvB,IAAIkE,UAAU,CAAClE,MAAM,GAAG,CAAC,IAAIM,QAAQ,CAAC,CAAC,CAAC,CAAC5B,IAAI,KAAKlC,IAAI,CAAC4E,OAAO,EAAEL,GAAG,IAAI,OAAO;QAC9EA,GAAG,IAAIT,QAAQ,CAAC+E,IAAI,CAAC,EAAE,CAAC;MAC1B;MAEA,IAAItE,GAAG,CAACA,GAAG,CAACf,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAAEe,GAAG,IAAI,IAAI;MAC7C,OAAOA,GAAG;IACZ;EACF,CAAC,CAAC,EAAE,CAAC;IACH7C,GAAG,EAAE,4BAA4B;IACjCE,KAAK,EAAE,SAASqG,0BAA0BA,CAACzF,GAAG,EAAET,KAAK,EAAE;MACrD,IAAIe,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAET,KAAK,CAAC;MAC7C,IAAIiB,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MACpB,OAAOE,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,IAAI,GAAGF,MAAM,GAAGf,KAAK;IACnD;EACF,CAAC,CAAC,CAAC;EAEH,OAAOyF,QAAQ;AACjB,CAAC,CAAClH,IAAI,CAAC;AAEP,IAAIwI,KAAK,GAAG,aAAa,UAAUxH,KAAK,EAAE;EACxC5B,SAAS,CAACoJ,KAAK,EAAExH,KAAK,CAAC;EAEvB,IAAIC,MAAM,GAAG3B,YAAY,CAACkJ,KAAK,CAAC;EAEhC,SAASA,KAAKA,CAAA,EAAG;IACfhJ,eAAe,CAAC,IAAI,EAAEgJ,KAAK,CAAC;IAE5B,OAAOvH,MAAM,CAAC0C,KAAK,CAAC,IAAI,EAAE8E,SAAS,CAAC;EACtC;EAEA7I,YAAY,CAAC4I,KAAK,EAAE,CAAC;IACnBpH,GAAG,EAAE,OAAO;IACZE,KAAK;IACL;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MAC7B,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIU,GAAG,GAAGV,OAAO,CAACU,GAAG;MACrB,IAAIM,MAAM,GAAGxC,IAAI,CAAC0I,eAAe,CAACxG,GAAG,EAAET,KAAK,GAAG,CAAC,CAAC;MACjD,IAAI,CAACoC,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,GAAG,CAAC,EAAEe,MAAM,CAAC;MAC9CA,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;MAC1CA,MAAM,GAAG,IAAI,CAAC+B,YAAY,CAAC/B,MAAM,CAAC;MAClC,OAAOA,MAAM;IACf;EACF,CAAC,CAAC,CAAC;EAEH,OAAOgG,KAAK;AACd,CAAC,CAACxI,IAAI,CAAC;AAEP,IAAI2I,KAAK,GAAG;EACVC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,MAAM;EACZC,KAAK,EAAE;AACT,CAAC;AACD,IAAIC,UAAU,GAAG,aAAa,UAAU/H,KAAK,EAAE;EAC7C5B,SAAS,CAAC2J,UAAU,EAAE/H,KAAK,CAAC;EAE5B,IAAIC,MAAM,GAAG3B,YAAY,CAACyJ,UAAU,CAAC;EAErC,SAASA,UAAUA,CAACnH,IAAI,EAAEC,KAAK,EAAE;IAC/B,IAAIC,KAAK;IAETtC,eAAe,CAAC,IAAI,EAAEuJ,UAAU,CAAC;IAEjCjH,KAAK,GAAGb,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEU,IAAI,EAAEC,KAAK,CAAC;IACtCC,KAAK,CAACkH,WAAW,GAAG,IAAI;IACxBlH,KAAK,CAACmH,QAAQ,GAAGN,KAAK,CAACC,IAAI;IAC3B9G,KAAK,CAACoH,MAAM,GAAG,IAAI;IACnB,OAAOpH,KAAK;EACd;EAEAlC,YAAY,CAACmJ,UAAU,EAAE,CAAC;IACxB3H,GAAG,EAAE,uBAAuB;IAC5BC,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB,OAAO,IAAI,CAAC4H,QAAQ,KAAKN,KAAK,CAACE,IAAI;IACrC;EACF,CAAC,EAAE;IACDzH,GAAG,EAAE,UAAU;IACfC,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB,IAAI,CAAC,IAAI,CAACwC,UAAU,IAAI,CAAC,IAAI,CAACrC,OAAO,EAAE,OAAO,IAAI;MAClD,IAAI2H,gBAAgB,GAAG,IAAI,CAACtF,UAAU;QAClCpC,KAAK,GAAG0H,gBAAgB,CAAC1H,KAAK;QAC9BmC,GAAG,GAAGuF,gBAAgB,CAACvF,GAAG;MAC9B,IAAIkE,aAAa,GAAG,IAAI,CAACtG,OAAO;QAC5Be,MAAM,GAAGuF,aAAa,CAACvF,MAAM;QAC7BL,GAAG,GAAG4F,aAAa,CAAC5F,GAAG;MAC3B,IAAI,IAAI,CAAC2B,UAAU,CAACuF,OAAO,CAAC,CAAC,EAAE,OAAO,EAAE;MACxC,IAAIC,WAAW,GAAG,IAAI;MACtB,IAAI3G,EAAE,GAAGR,GAAG,CAAC0B,GAAG,GAAG,CAAC,CAAC;MAErB,OAAOlB,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,GAAG,EAAE;QAC/CkB,GAAG,IAAI,CAAC;QAER,IAAIA,GAAG,IAAInC,KAAK,EAAE;UAChB,IAAI,IAAI,CAACwH,QAAQ,KAAKN,KAAK,CAACE,IAAI,EAAE,MAAM,KAAK,OAAO,EAAE,CAAC,CAAC;QAC1D;QAEA,IAAInG,EAAE,KAAK,IAAI,EAAE2G,WAAW,GAAGzF,GAAG;QAClClB,EAAE,GAAGR,GAAG,CAAC0B,GAAG,GAAG,CAAC,CAAC;MACnB;MAEA,IAAI0F,SAAS,GAAG1F,GAAG,GAAG,CAAC;MAEvB,IAAIyF,WAAW,EAAE;QACf,IAAI,IAAI,CAACJ,QAAQ,KAAKN,KAAK,CAACE,IAAI,EAAE;UAChCS,SAAS,GAAGD,WAAW;UACvBzF,GAAG,GAAG,IAAI,CAACC,UAAU,CAACD,GAAG;QAC3B,CAAC,MAAM;UACLA,GAAG,GAAGyF,WAAW;QACnB;MACF;MAEA,IAAIE,EAAE,GAAGhH,MAAM,GAAG,IAAI,CAACyG,WAAW;MAClC,IAAIQ,MAAM,GAAG,IAAI,CAAC5H,IAAI,KAAKlC,IAAI,CAAC+J,YAAY;MAC5C,IAAIC,OAAO,GAAG,IAAI;MAClB,IAAIzF,GAAG,GAAG,EAAE;MACZ,IAAI0F,GAAG,GAAG,EAAE;MACZ,IAAIC,gBAAgB,GAAG,KAAK;MAE5B,KAAK,IAAI/E,CAAC,GAAGpD,KAAK,EAAEoD,CAAC,GAAGjB,GAAG,EAAE,EAAEiB,CAAC,EAAE;QAChC,KAAK,IAAI1F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoK,EAAE,EAAE,EAAEpK,CAAC,EAAE;UAC3B,IAAI+C,GAAG,CAAC2C,CAAC,CAAC,KAAK,GAAG,EAAE;UACpBA,CAAC,IAAI,CAAC;QACR;QAEA,IAAIgF,GAAG,GAAG3H,GAAG,CAAC2C,CAAC,CAAC;QAEhB,IAAIgF,GAAG,KAAK,IAAI,EAAE;UAChB,IAAIF,GAAG,KAAK,IAAI,EAAE1F,GAAG,IAAI,IAAI,CAAC,KAAK0F,GAAG,GAAG,IAAI;QAC/C,CAAC,MAAM;UACL,IAAIG,OAAO,GAAG9J,IAAI,CAAC+C,SAAS,CAACb,GAAG,EAAE2C,CAAC,CAAC;UACpC,IAAIkF,IAAI,GAAG7H,GAAG,CAACgC,KAAK,CAACW,CAAC,EAAEiF,OAAO,CAAC;UAChCjF,CAAC,GAAGiF,OAAO;UAEX,IAAIN,MAAM,KAAKK,GAAG,KAAK,GAAG,IAAIA,GAAG,KAAK,IAAI,CAAC,IAAIhF,CAAC,GAAGyE,SAAS,EAAE;YAC5D,IAAIK,GAAG,KAAK,GAAG,EAAEA,GAAG,GAAG,IAAI,CAAC,KAAK,IAAI,CAACC,gBAAgB,IAAI,CAACF,OAAO,IAAIC,GAAG,KAAK,IAAI,EAAEA,GAAG,GAAG,MAAM;YAChG1F,GAAG,IAAI0F,GAAG,GAAGI,IAAI,CAAC,CAAC;;YAEnBJ,GAAG,GAAGG,OAAO,GAAGlG,GAAG,IAAI1B,GAAG,CAAC4H,OAAO,CAAC,IAAI,EAAE;YACzCF,gBAAgB,GAAG,IAAI;UACzB,CAAC,MAAM;YACL3F,GAAG,IAAI0F,GAAG,GAAGI,IAAI;YACjBJ,GAAG,GAAGH,MAAM,IAAI3E,CAAC,GAAGyE,SAAS,GAAG,GAAG,GAAG,IAAI;YAC1CM,gBAAgB,GAAG,KAAK;UAC1B;UAEA,IAAIF,OAAO,IAAIK,IAAI,KAAK,EAAE,EAAEL,OAAO,GAAG,KAAK;QAC7C;MACF;MAEA,OAAO,IAAI,CAACT,QAAQ,KAAKN,KAAK,CAACG,KAAK,GAAG7E,GAAG,GAAGA,GAAG,GAAG,IAAI;IACzD;EACF,CAAC,EAAE;IACD7C,GAAG,EAAE,kBAAkB;IACvBE,KAAK,EAAE,SAAS0I,gBAAgBA,CAACvI,KAAK,EAAE;MACtC,IAAIS,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;MAC1B,IAAIM,MAAM,GAAGf,KAAK,GAAG,CAAC;MACtB,IAAI8H,EAAE,GAAG,EAAE;MAEX,OAAO,IAAI,EAAE;QACX,IAAI7G,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;QAEpB,QAAQE,EAAE;UACR,KAAK,GAAG;YACN,IAAI,CAACuG,QAAQ,GAAGN,KAAK,CAACG,KAAK;YAC3B;UAEF,KAAK,GAAG;YACN,IAAI,CAACG,QAAQ,GAAGN,KAAK,CAACE,IAAI;YAC1B;UAEF,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;UACR,KAAK,GAAG;YACNU,EAAE,IAAI7G,EAAE;YACR;UAEF;YACE,IAAI,CAACsG,WAAW,GAAGiB,MAAM,CAACV,EAAE,CAAC,IAAI,IAAI;YACrC,IAAI,CAACL,MAAM,GAAG,IAAIpJ,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;YACtC,OAAOA,MAAM;QACjB;QAEAA,MAAM,IAAI,CAAC;MACb;IACF;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,iBAAiB;IACtBE,KAAK,EAAE,SAAS4I,eAAeA,CAACzI,KAAK,EAAE;MACrC,IAAI0I,cAAc,GAAG,IAAI,CAAC3I,OAAO;QAC7Be,MAAM,GAAG4H,cAAc,CAAC5H,MAAM;QAC9BL,GAAG,GAAGiI,cAAc,CAACjI,GAAG;MAC5B,IAAIkI,QAAQ,GAAG,CAAC,CAAC,IAAI,CAACpB,WAAW;MACjC,IAAIxG,MAAM,GAAGf,KAAK;MAClB,IAAI4I,QAAQ,GAAG5I,KAAK;MACpB,IAAI6I,cAAc,GAAG,CAAC;MAEtB,KAAK,IAAI5H,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC,EAAEE,EAAE,KAAK,IAAI,EAAEA,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC,EAAE;QACxDA,MAAM,IAAI,CAAC;QACX,IAAIxC,IAAI,CAACyH,kBAAkB,CAACvF,GAAG,EAAEM,MAAM,CAAC,EAAE;QAC1C,IAAIoB,GAAG,GAAG5D,IAAI,CAACuK,gBAAgB,CAACrI,GAAG,EAAEK,MAAM,EAAEC,MAAM,CAAC,CAAC,CAAC;;QAEtD,IAAIoB,GAAG,KAAK,IAAI,EAAE;QAClB,IAAI4G,IAAI,GAAGtI,GAAG,CAAC0B,GAAG,CAAC;QACnB,IAAI6G,UAAU,GAAG7G,GAAG,IAAIpB,MAAM,GAAGD,MAAM,CAAC;QAExC,IAAI,CAAC,IAAI,CAACyG,WAAW,EAAE;UACrB;UACA,IAAI9G,GAAG,CAAC0B,GAAG,CAAC,KAAK,IAAI,EAAE;YACrB;YACA,IAAI6G,UAAU,GAAGH,cAAc,EAAE;cAC/B,IAAItE,GAAG,GAAG,iGAAiG;cAC3G,IAAI,CAAC1D,KAAK,GAAG,IAAIpC,iBAAiB,CAAC,IAAI,EAAE8F,GAAG,CAAC;YAC/C;YAEA,IAAI,CAACgD,WAAW,GAAGyB,UAAU;UAC/B,CAAC,MAAM,IAAIA,UAAU,GAAGH,cAAc,EAAE;YACtC;YACAA,cAAc,GAAGG,UAAU;UAC7B;QACF,CAAC,MAAM,IAAID,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIC,UAAU,GAAG,IAAI,CAACzB,WAAW,EAAE;UACjE,IAAI9G,GAAG,CAAC0B,GAAG,CAAC,KAAK,GAAG,EAAE;UAEtB,IAAI,CAAC,IAAI,CAACtB,KAAK,EAAE;YACf,IAAIoI,IAAI,GAAGN,QAAQ,GAAG,gCAAgC,GAAG,YAAY;YAErE,IAAIlE,IAAI,GAAG,qDAAqD,CAACyE,MAAM,CAACD,IAAI,CAAC;YAE7E,IAAI,CAACpI,KAAK,GAAG,IAAIpC,iBAAiB,CAAC,IAAI,EAAEgG,IAAI,CAAC;UAChD;QACF;QAEA,IAAIhE,GAAG,CAAC0B,GAAG,CAAC,KAAK,IAAI,EAAE;UACrBpB,MAAM,GAAGoB,GAAG;QACd,CAAC,MAAM;UACLpB,MAAM,GAAG6H,QAAQ,GAAGrK,IAAI,CAAC+C,SAAS,CAACb,GAAG,EAAE0B,GAAG,CAAC;QAC9C;MACF;MAEA,IAAI,IAAI,CAACqF,QAAQ,KAAKN,KAAK,CAACE,IAAI,EAAE;QAChCrG,MAAM,GAAGN,GAAG,CAACmI,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAAC,GAAGA,QAAQ;MAClD;MAEA,IAAI,CAACxG,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,GAAG,CAAC,EAAEe,MAAM,CAAC;MAC9C,OAAOA,MAAM;IACf;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDpB,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIU,GAAG,GAAGV,OAAO,CAACU,GAAG;MACrB,IAAIM,MAAM,GAAG,IAAI,CAACwH,gBAAgB,CAACvI,KAAK,CAAC;MACzCe,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;MAC1CA,MAAM,GAAG,IAAI,CAAC+B,YAAY,CAAC/B,MAAM,CAAC;MAClCA,MAAM,GAAG,IAAI,CAAC0H,eAAe,CAAC1H,MAAM,CAAC;MACrC,OAAOA,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,eAAe;IACpBE,KAAK,EAAE,SAASwC,aAAaA,CAACC,EAAE,EAAEvB,MAAM,EAAE;MACxCA,MAAM,GAAGpC,IAAI,CAACE,eAAe,CAACyI,UAAU,CAACrF,SAAS,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,CAACxC,IAAI,CAAC,IAAI,EAAE6C,EAAE,EAAEvB,MAAM,CAAC;MAClG,OAAO,IAAI,CAAC0G,MAAM,GAAG,IAAI,CAACA,MAAM,CAACZ,YAAY,CAACvE,EAAE,EAAEvB,MAAM,CAAC,GAAGA,MAAM;IACpE;EACF,CAAC,CAAC,CAAC;EAEH,OAAOuG,UAAU;AACnB,CAAC,CAAC/I,IAAI,CAAC;AAEP,IAAI4K,cAAc,GAAG,aAAa,UAAU5J,KAAK,EAAE;EACjD5B,SAAS,CAACwL,cAAc,EAAE5J,KAAK,CAAC;EAEhC,IAAIC,MAAM,GAAG3B,YAAY,CAACsL,cAAc,CAAC;EAEzC,SAASA,cAAcA,CAAChJ,IAAI,EAAEC,KAAK,EAAE;IACnC,IAAIC,KAAK;IAETtC,eAAe,CAAC,IAAI,EAAEoL,cAAc,CAAC;IAErC9I,KAAK,GAAGb,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEU,IAAI,EAAEC,KAAK,CAAC;IACtCC,KAAK,CAACyB,KAAK,GAAG,IAAI;IAClB,OAAOzB,KAAK;EACd;EAEAlC,YAAY,CAACgL,cAAc,EAAE,CAAC;IAC5BxJ,GAAG,EAAE,oBAAoB;IACzBE,KAAK,EAAE,SAASuJ,kBAAkBA,CAAA,EAAG;MACnC,IAAIC,GAAG,GAAGrC,SAAS,CAACvF,MAAM,GAAG,CAAC,IAAIuF,SAAS,CAAC,CAAC,CAAC,KAAKN,SAAS,GAAGM,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAClF,KAAK,CAACL,MAAM;MAC/F,IAAInB,IAAI,GAAG,IAAI,CAACwB,KAAK,CAACuH,GAAG,GAAG,CAAC,CAAC;MAC9B,OAAO,CAAC,CAAC/I,IAAI,KAAKA,IAAI,CAACgJ,QAAQ,IAAIhJ,IAAI,CAACH,IAAI,KAAKlC,IAAI,CAAC4E,OAAO,IAAI,IAAI,CAACuG,kBAAkB,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC;IACpG;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD1J,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIS,SAAS,GAAGT,OAAO,CAACS,SAAS;QAC7BC,GAAG,GAAGV,OAAO,CAACU,GAAG;MACrB,IAAIK,MAAM,GAAGf,OAAO,CAACe,MAAM;QACvBH,SAAS,GAAGZ,OAAO,CAACY,SAAS;MACjC,IAAI4I,IAAI,GAAG9I,GAAG,CAACT,KAAK,CAAC,CAAC,CAAC;;MAEvB,IAAI,CAAC8B,KAAK,GAAG,CAAC;QACZyH,IAAI,EAAEA,IAAI;QACVxI,MAAM,EAAEf;MACV,CAAC,CAAC;MACF,IAAIe,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAET,KAAK,GAAG,CAAC,CAAC;MACjDuJ,IAAI,GAAG9I,GAAG,CAACM,MAAM,CAAC;MAElB,OAAOwI,IAAI,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;QAC3C,QAAQA,IAAI;UACV,KAAK,IAAI;YACP;cACE5I,SAAS,GAAGI,MAAM,GAAG,CAAC;cACtB,IAAIS,KAAK,GAAGjD,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEE,SAAS,CAAC;cAEhD,IAAIF,GAAG,CAACe,KAAK,CAAC,KAAK,IAAI,EAAE;gBACvB,IAAIJ,SAAS,GAAG,IAAI9B,SAAS,CAAC,CAAC;gBAC/BqB,SAAS,GAAGS,SAAS,CAACtB,KAAK,CAAC;kBAC1BW,GAAG,EAAEA;gBACP,CAAC,EAAEE,SAAS,CAAC;gBACb,IAAI,CAACmB,KAAK,CAACP,IAAI,CAACH,SAAS,CAAC;cAC5B;cAEAL,MAAM,GAAGxC,IAAI,CAACmD,WAAW,CAACjB,GAAG,EAAEE,SAAS,CAAC;cAEzC,IAAII,MAAM,IAAIJ,SAAS,GAAGG,MAAM,EAAE;gBAChCyI,IAAI,GAAG9I,GAAG,CAACM,MAAM,CAAC;gBAElB,IAAIA,MAAM,GAAGJ,SAAS,GAAGG,MAAM,IAAIyI,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;kBAC/D,IAAIhF,GAAG,GAAG,6CAA6C;kBACvD,IAAI,CAAC1D,KAAK,GAAG,IAAIpC,iBAAiB,CAAC,IAAI,EAAE8F,GAAG,CAAC;gBAC/C;cACF;YACF;YACA;UAEF,KAAK,GAAG;YACN;cACE,IAAI,CAACzC,KAAK,CAACP,IAAI,CAAC;gBACdgI,IAAI,EAAEA,IAAI;gBACVxI,MAAM,EAAEA;cACV,CAAC,CAAC;cACFA,MAAM,IAAI,CAAC;YACb;YACA;UAEF,KAAK,GAAG;YACN;cACE,IAAIqD,OAAO,GAAG,IAAIxB,OAAO,CAAC,CAAC;cAC3B7B,MAAM,GAAGqD,OAAO,CAACtE,KAAK,CAAC;gBACrBW,GAAG,EAAEA;cACP,CAAC,EAAEM,MAAM,CAAC;cACV,IAAI,CAACe,KAAK,CAACP,IAAI,CAAC6C,OAAO,CAAC;YAC1B;YACA;UAEF,KAAK,GAAG;UACR,KAAK,GAAG;YACN;cACE,IAAIE,IAAI,GAAG7D,GAAG,CAACM,MAAM,GAAG,CAAC,CAAC;cAE1B,IAAIuD,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG;cAAI;cACtEiF,IAAI,KAAK,GAAG,IAAI,IAAI,CAACH,kBAAkB,CAAC,CAAC,EAAE;gBACzC,IAAI,CAACtH,KAAK,CAACP,IAAI,CAAC;kBACdgI,IAAI,EAAEA,IAAI;kBACVxI,MAAM,EAAEA;gBACV,CAAC,CAAC;gBACFA,MAAM,IAAI,CAAC;gBACX;cACF;YACF;UACF;;UAEA;YACE;cACE,IAAIT,IAAI,GAAGE,SAAS,CAAC;gBACnBE,WAAW,EAAE,KAAK;gBAClBkB,YAAY,EAAE,KAAK;gBACnB4E,MAAM,EAAE,IAAI;gBACZ1F,MAAM,EAAE,CAAC,CAAC;gBACVH,SAAS,EAAEA,SAAS;gBACpBkB,MAAM,EAAE;cACV,CAAC,EAAEd,MAAM,CAAC;cAEV,IAAI,CAACT,IAAI,EAAE;gBACT;gBACA,IAAI,CAAC8B,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;gBAC1C,OAAOA,MAAM;cACf;cAEA,IAAI,CAACe,KAAK,CAACP,IAAI,CAACjB,IAAI,CAAC;cACrBS,MAAM,GAAGxC,IAAI,CAAC0F,eAAe,CAACxD,GAAG,EAAEH,IAAI,CAACL,KAAK,CAACkC,GAAG,CAAC;YACpD;QACJ;QAEApB,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;QAC1CwI,IAAI,GAAG9I,GAAG,CAACM,MAAM,CAAC;MACpB;MAEA,IAAI,CAACqB,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,EAAEe,MAAM,GAAG,CAAC,CAAC;MAE9C,IAAIwI,IAAI,EAAE;QACR,IAAI,CAACzH,KAAK,CAACP,IAAI,CAAC;UACdgI,IAAI,EAAEA,IAAI;UACVxI,MAAM,EAAEA;QACV,CAAC,CAAC;QACFA,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,GAAG,CAAC,CAAC;QAC9CA,MAAM,GAAG,IAAI,CAAC+B,YAAY,CAAC/B,MAAM,CAAC;MACpC;MAEA,OAAOA,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,eAAe;IACpBE,KAAK,EAAE,SAASwC,aAAaA,CAACC,EAAE,EAAEvB,MAAM,EAAE;MACxCA,MAAM,GAAGpC,IAAI,CAACE,eAAe,CAACsK,cAAc,CAAClH,SAAS,CAAC,EAAE,eAAe,EAAE,IAAI,CAAC,CAACxC,IAAI,CAAC,IAAI,EAAE6C,EAAE,EAAEvB,MAAM,CAAC;MACtG,IAAI,CAACe,KAAK,CAAC8C,OAAO,CAAC,UAAUtE,IAAI,EAAE;QACjC,IAAIA,IAAI,YAAY/B,IAAI,EAAE;UACxBwC,MAAM,GAAGT,IAAI,CAAC+B,aAAa,CAACC,EAAE,EAAEvB,MAAM,CAAC;QACzC,CAAC,MAAM,IAAIuB,EAAE,CAACb,MAAM,KAAK,CAAC,EAAE;UAC1BnB,IAAI,CAACkJ,UAAU,GAAGlJ,IAAI,CAACS,MAAM;QAC/B,CAAC,MAAM;UACL,IAAIqC,CAAC,GAAGrC,MAAM;UAEd,OAAOqC,CAAC,GAAGd,EAAE,CAACb,MAAM,EAAE;YACpB,IAAIa,EAAE,CAACc,CAAC,CAAC,GAAG9C,IAAI,CAACS,MAAM,EAAE,MAAM,KAAK,EAAEqC,CAAC;UACzC;UAEA9C,IAAI,CAACkJ,UAAU,GAAGlJ,IAAI,CAACS,MAAM,GAAGqC,CAAC;UACjCrC,MAAM,GAAGqC,CAAC;QACZ;MACF,CAAC,CAAC;MACF,OAAOrC,MAAM;IACf;EACF,CAAC,EAAE;IACDpB,GAAG,EAAE,UAAU;IACfE,KAAK,EAAE,SAAS0C,QAAQA,CAAA,EAAG;MACzB,IAAI9B,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;QACtBqB,KAAK,GAAG,IAAI,CAACA,KAAK;QAClB7B,KAAK,GAAG,IAAI,CAACA,KAAK;QAClBJ,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIA,KAAK,IAAI,IAAI,EAAE,OAAOA,KAAK;MAC/B,IAAI4J,KAAK,GAAG3H,KAAK,CAAC4H,MAAM,CAAC,UAAU7E,IAAI,EAAE;QACvC,OAAOA,IAAI,YAAYtG,IAAI;MAC7B,CAAC,CAAC;MACF,IAAIiE,GAAG,GAAG,EAAE;MACZ,IAAIiB,OAAO,GAAGxD,KAAK,CAACD,KAAK;MACzByJ,KAAK,CAAC7E,OAAO,CAAC,UAAUtE,IAAI,EAAE;QAC5B,IAAIqJ,MAAM,GAAGlJ,GAAG,CAACgC,KAAK,CAACgB,OAAO,EAAEnD,IAAI,CAACL,KAAK,CAACD,KAAK,CAAC;QACjDyD,OAAO,GAAGnD,IAAI,CAACL,KAAK,CAACkC,GAAG;QACxBK,GAAG,IAAImH,MAAM,GAAGjH,MAAM,CAACpC,IAAI,CAAC;QAE5B,IAAIkC,GAAG,CAACA,GAAG,CAACf,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,IAAIhB,GAAG,CAACgD,OAAO,GAAG,CAAC,CAAC,KAAK,IAAI,IAAIhD,GAAG,CAACgD,OAAO,CAAC,KAAK,IAAI,EAAE;UACtF;UACA;UACA;UACAA,OAAO,IAAI,CAAC;QACd;MACF,CAAC,CAAC;MACFjB,GAAG,IAAI/B,GAAG,CAACgC,KAAK,CAACgB,OAAO,EAAExD,KAAK,CAACkC,GAAG,CAAC;MACpC,OAAO5D,IAAI,CAACoE,mBAAmB,CAAClC,GAAG,EAAER,KAAK,CAACkC,GAAG,EAAEK,GAAG,CAAC;IACtD;EACF,CAAC,CAAC,CAAC;EAEH,OAAO2G,cAAc;AACvB,CAAC,CAAC5K,IAAI,CAAC;AAEP,IAAIqL,WAAW,GAAG,aAAa,UAAUrK,KAAK,EAAE;EAC9C5B,SAAS,CAACiM,WAAW,EAAErK,KAAK,CAAC;EAE7B,IAAIC,MAAM,GAAG3B,YAAY,CAAC+L,WAAW,CAAC;EAEtC,SAASA,WAAWA,CAAA,EAAG;IACrB7L,eAAe,CAAC,IAAI,EAAE6L,WAAW,CAAC;IAElC,OAAOpK,MAAM,CAAC0C,KAAK,CAAC,IAAI,EAAE8E,SAAS,CAAC;EACtC;EAEA7I,YAAY,CAACyL,WAAW,EAAE,CAAC;IACzBjK,GAAG,EAAE,UAAU;IACfC,GAAG;IACH;AACJ;AACA;IACI,SAASA,GAAGA,CAAA,EAAG;MACb,IAAI,CAAC,IAAI,CAACwC,UAAU,IAAI,CAAC,IAAI,CAACrC,OAAO,EAAE,OAAO,IAAI;MAClD,IAAI8J,MAAM,GAAG,EAAE;MACf,IAAInC,gBAAgB,GAAG,IAAI,CAACtF,UAAU;QAClCpC,KAAK,GAAG0H,gBAAgB,CAAC1H,KAAK;QAC9BmC,GAAG,GAAGuF,gBAAgB,CAACvF,GAAG;MAC9B,IAAIkE,aAAa,GAAG,IAAI,CAACtG,OAAO;QAC5Be,MAAM,GAAGuF,aAAa,CAACvF,MAAM;QAC7BL,GAAG,GAAG4F,aAAa,CAAC5F,GAAG;MAC3B,IAAIA,GAAG,CAAC0B,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE0H,MAAM,CAACtI,IAAI,CAAC,IAAIxC,eAAe,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC,CAAC,CAAC;MAC5F;;MAEA,IAAIyD,GAAG,GAAG,EAAE;MAEZ,KAAK,IAAIY,CAAC,GAAGpD,KAAK,GAAG,CAAC,EAAEoD,CAAC,GAAGjB,GAAG,GAAG,CAAC,EAAE,EAAEiB,CAAC,EAAE;QACxC,IAAInC,EAAE,GAAGR,GAAG,CAAC2C,CAAC,CAAC;QAEf,IAAInC,EAAE,KAAK,IAAI,EAAE;UACf,IAAI1C,IAAI,CAACyH,kBAAkB,CAACvF,GAAG,EAAE2C,CAAC,GAAG,CAAC,CAAC,EAAEyG,MAAM,CAACtI,IAAI,CAAC,IAAI9C,iBAAiB,CAAC,IAAI,EAAE,mEAAmE,CAAC,CAAC;UAEtJ,IAAIqL,iBAAiB,GAAGvL,IAAI,CAACwL,WAAW,CAACtJ,GAAG,EAAE2C,CAAC,EAAEtC,MAAM,CAAC;YACpDkJ,IAAI,GAAGF,iBAAiB,CAACE,IAAI;YAC7BjJ,MAAM,GAAG+I,iBAAiB,CAAC/I,MAAM;YACjCF,KAAK,GAAGiJ,iBAAiB,CAACjJ,KAAK;UAEnC2B,GAAG,IAAIwH,IAAI;UACX5G,CAAC,GAAGrC,MAAM;UACV,IAAIF,KAAK,EAAEgJ,MAAM,CAACtI,IAAI,CAAC,IAAI9C,iBAAiB,CAAC,IAAI,EAAE,mEAAmE,CAAC,CAAC;QAC1H,CAAC,MAAM,IAAIwC,EAAE,KAAK,IAAI,EAAE;UACtBmC,CAAC,IAAI,CAAC;UAEN,QAAQ3C,GAAG,CAAC2C,CAAC,CAAC;YACZ,KAAK,GAAG;cACNZ,GAAG,IAAI,IAAI;cACX;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,MAAM;cACb;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,IAAI;cACX;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,MAAM;cACb;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,IAAI;cACX;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,IAAI;cACX;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,IAAI;cACX;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,IAAI;cACX;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,IAAI;cACX;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,MAAM;cACb;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,MAAM;cACb;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,QAAQ;cACf;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,QAAQ;cACf;YACF;;YAEA,KAAK,GAAG;cACNA,GAAG,IAAI,GAAG;cACV;YAEF,KAAK,GAAG;cACNA,GAAG,IAAI,GAAG;cACV;YAEF,KAAK,GAAG;cACNA,GAAG,IAAI,GAAG;cACV;YAEF,KAAK,IAAI;cACPA,GAAG,IAAI,IAAI;cACX;YAEF,KAAK,IAAI;cACPA,GAAG,IAAI,IAAI;cACX;YAEF,KAAK,GAAG;cACNA,GAAG,IAAI,IAAI,CAACyH,aAAa,CAAC7G,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEyG,MAAM,CAAC;cAC3CzG,CAAC,IAAI,CAAC;cACN;YAEF,KAAK,GAAG;cACNZ,GAAG,IAAI,IAAI,CAACyH,aAAa,CAAC7G,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEyG,MAAM,CAAC;cAC3CzG,CAAC,IAAI,CAAC;cACN;YAEF,KAAK,GAAG;cACNZ,GAAG,IAAI,IAAI,CAACyH,aAAa,CAAC7G,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEyG,MAAM,CAAC;cAC3CzG,CAAC,IAAI,CAAC;cACN;YAEF,KAAK,IAAI;cACP;cACA,OAAO3C,GAAG,CAAC2C,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,IAAI3C,GAAG,CAAC2C,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;gBAChDA,CAAC,IAAI,CAAC;cACR;cAEA;YAEF;cACEyG,MAAM,CAACtI,IAAI,CAAC,IAAIxC,eAAe,CAAC,IAAI,EAAE,0BAA0B,CAACmK,MAAM,CAACzI,GAAG,CAACyJ,MAAM,CAAC9G,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;cAC/FZ,GAAG,IAAI,IAAI,GAAG/B,GAAG,CAAC2C,CAAC,CAAC;UACxB;QACF,CAAC,MAAM,IAAInC,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,IAAI,EAAE;UACpC;UACA,IAAIkJ,OAAO,GAAG/G,CAAC;UACf,IAAIkB,IAAI,GAAG7D,GAAG,CAAC2C,CAAC,GAAG,CAAC,CAAC;UAErB,OAAOkB,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EAAE;YACpClB,CAAC,IAAI,CAAC;YACNkB,IAAI,GAAG7D,GAAG,CAAC2C,CAAC,GAAG,CAAC,CAAC;UACnB;UAEA,IAAIkB,IAAI,KAAK,IAAI,EAAE9B,GAAG,IAAIY,CAAC,GAAG+G,OAAO,GAAG1J,GAAG,CAACgC,KAAK,CAAC0H,OAAO,EAAE/G,CAAC,GAAG,CAAC,CAAC,GAAGnC,EAAE;QACxE,CAAC,MAAM;UACLuB,GAAG,IAAIvB,EAAE;QACX;MACF;MAEA,OAAO4I,MAAM,CAACpI,MAAM,GAAG,CAAC,GAAG;QACzBoI,MAAM,EAAEA,MAAM;QACdrH,GAAG,EAAEA;MACP,CAAC,GAAGA,GAAG;IACT;EACF,CAAC,EAAE;IACD7C,GAAG,EAAE,eAAe;IACpBE,KAAK,EAAE,SAASoK,aAAaA,CAAClJ,MAAM,EAAEU,MAAM,EAAEoI,MAAM,EAAE;MACpD,IAAIpJ,GAAG,GAAG,IAAI,CAACV,OAAO,CAACU,GAAG;MAC1B,IAAI2J,EAAE,GAAG3J,GAAG,CAACyJ,MAAM,CAACnJ,MAAM,EAAEU,MAAM,CAAC;MACnC,IAAI4I,EAAE,GAAGD,EAAE,CAAC3I,MAAM,KAAKA,MAAM,IAAI,gBAAgB,CAAC6I,IAAI,CAACF,EAAE,CAAC;MAC1D,IAAIG,IAAI,GAAGF,EAAE,GAAGG,QAAQ,CAACJ,EAAE,EAAE,EAAE,CAAC,GAAGK,GAAG;MAEtC,IAAIC,KAAK,CAACH,IAAI,CAAC,EAAE;QACfV,MAAM,CAACtI,IAAI,CAAC,IAAIxC,eAAe,CAAC,IAAI,EAAE,0BAA0B,CAACmK,MAAM,CAACzI,GAAG,CAACyJ,MAAM,CAACnJ,MAAM,GAAG,CAAC,EAAEU,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC7G,OAAOhB,GAAG,CAACyJ,MAAM,CAACnJ,MAAM,GAAG,CAAC,EAAEU,MAAM,GAAG,CAAC,CAAC;MAC3C;MAEA,OAAOiB,MAAM,CAACiI,aAAa,CAACJ,IAAI,CAAC;IACnC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD5K,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIU,GAAG,GAAGV,OAAO,CAACU,GAAG;MACrB,IAAIM,MAAM,GAAG6I,WAAW,CAACgB,UAAU,CAACnK,GAAG,EAAET,KAAK,GAAG,CAAC,CAAC;MACnD,IAAI,CAACoC,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;MAC1CA,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;MAC1CA,MAAM,GAAG,IAAI,CAAC+B,YAAY,CAAC/B,MAAM,CAAC;MAClC,OAAOA,MAAM;IACf;EACF,CAAC,CAAC,EAAE,CAAC;IACHpB,GAAG,EAAE,YAAY;IACjBE,KAAK,EAAE,SAAS+K,UAAUA,CAACnK,GAAG,EAAEM,MAAM,EAAE;MACtC,IAAIE,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAEpB,OAAOE,EAAE,IAAIA,EAAE,KAAK,GAAG,EAAE;QACvBF,MAAM,IAAIE,EAAE,KAAK,IAAI,GAAG,CAAC,GAAG,CAAC;QAC7BA,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAClB;MAEA,OAAOA,MAAM,GAAG,CAAC;IACnB;EACF,CAAC,CAAC,CAAC;EAEH,OAAO6I,WAAW;AACpB,CAAC,CAACrL,IAAI,CAAC;AAEP,IAAIsM,WAAW,GAAG,aAAa,UAAUtL,KAAK,EAAE;EAC9C5B,SAAS,CAACkN,WAAW,EAAEtL,KAAK,CAAC;EAE7B,IAAIC,MAAM,GAAG3B,YAAY,CAACgN,WAAW,CAAC;EAEtC,SAASA,WAAWA,CAAA,EAAG;IACrB9M,eAAe,CAAC,IAAI,EAAE8M,WAAW,CAAC;IAElC,OAAOrL,MAAM,CAAC0C,KAAK,CAAC,IAAI,EAAE8E,SAAS,CAAC;EACtC;EAEA7I,YAAY,CAAC0M,WAAW,EAAE,CAAC;IACzBlL,GAAG,EAAE,UAAU;IACfC,GAAG;IACH;AACJ;AACA;IACI,SAASA,GAAGA,CAAA,EAAG;MACb,IAAI,CAAC,IAAI,CAACwC,UAAU,IAAI,CAAC,IAAI,CAACrC,OAAO,EAAE,OAAO,IAAI;MAClD,IAAI8J,MAAM,GAAG,EAAE;MACf,IAAInC,gBAAgB,GAAG,IAAI,CAACtF,UAAU;QAClCpC,KAAK,GAAG0H,gBAAgB,CAAC1H,KAAK;QAC9BmC,GAAG,GAAGuF,gBAAgB,CAACvF,GAAG;MAC9B,IAAIkE,aAAa,GAAG,IAAI,CAACtG,OAAO;QAC5Be,MAAM,GAAGuF,aAAa,CAACvF,MAAM;QAC7BL,GAAG,GAAG4F,aAAa,CAAC5F,GAAG;MAC3B,IAAIA,GAAG,CAAC0B,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE0H,MAAM,CAACtI,IAAI,CAAC,IAAIxC,eAAe,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC;MAC1F,IAAIyD,GAAG,GAAG,EAAE;MAEZ,KAAK,IAAIY,CAAC,GAAGpD,KAAK,GAAG,CAAC,EAAEoD,CAAC,GAAGjB,GAAG,GAAG,CAAC,EAAE,EAAEiB,CAAC,EAAE;QACxC,IAAInC,EAAE,GAAGR,GAAG,CAAC2C,CAAC,CAAC;QAEf,IAAInC,EAAE,KAAK,IAAI,EAAE;UACf,IAAI1C,IAAI,CAACyH,kBAAkB,CAACvF,GAAG,EAAE2C,CAAC,GAAG,CAAC,CAAC,EAAEyG,MAAM,CAACtI,IAAI,CAAC,IAAI9C,iBAAiB,CAAC,IAAI,EAAE,mEAAmE,CAAC,CAAC;UAEtJ,IAAIqL,iBAAiB,GAAGvL,IAAI,CAACwL,WAAW,CAACtJ,GAAG,EAAE2C,CAAC,EAAEtC,MAAM,CAAC;YACpDkJ,IAAI,GAAGF,iBAAiB,CAACE,IAAI;YAC7BjJ,MAAM,GAAG+I,iBAAiB,CAAC/I,MAAM;YACjCF,KAAK,GAAGiJ,iBAAiB,CAACjJ,KAAK;UAEnC2B,GAAG,IAAIwH,IAAI;UACX5G,CAAC,GAAGrC,MAAM;UACV,IAAIF,KAAK,EAAEgJ,MAAM,CAACtI,IAAI,CAAC,IAAI9C,iBAAiB,CAAC,IAAI,EAAE,mEAAmE,CAAC,CAAC;QAC1H,CAAC,MAAM,IAAIwC,EAAE,KAAK,GAAG,EAAE;UACrBuB,GAAG,IAAIvB,EAAE;UACTmC,CAAC,IAAI,CAAC;UACN,IAAI3C,GAAG,CAAC2C,CAAC,CAAC,KAAK,GAAG,EAAEyG,MAAM,CAACtI,IAAI,CAAC,IAAIxC,eAAe,CAAC,IAAI,EAAE,iDAAiD,CAAC,CAAC;QAC/G,CAAC,MAAM,IAAIkC,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,IAAI,EAAE;UACpC;UACA,IAAIkJ,OAAO,GAAG/G,CAAC;UACf,IAAIkB,IAAI,GAAG7D,GAAG,CAAC2C,CAAC,GAAG,CAAC,CAAC;UAErB,OAAOkB,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EAAE;YACpClB,CAAC,IAAI,CAAC;YACNkB,IAAI,GAAG7D,GAAG,CAAC2C,CAAC,GAAG,CAAC,CAAC;UACnB;UAEA,IAAIkB,IAAI,KAAK,IAAI,EAAE9B,GAAG,IAAIY,CAAC,GAAG+G,OAAO,GAAG1J,GAAG,CAACgC,KAAK,CAAC0H,OAAO,EAAE/G,CAAC,GAAG,CAAC,CAAC,GAAGnC,EAAE;QACxE,CAAC,MAAM;UACLuB,GAAG,IAAIvB,EAAE;QACX;MACF;MAEA,OAAO4I,MAAM,CAACpI,MAAM,GAAG,CAAC,GAAG;QACzBoI,MAAM,EAAEA,MAAM;QACdrH,GAAG,EAAEA;MACP,CAAC,GAAGA,GAAG;IACT;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7C,GAAG,EAAE,OAAO;IACZE,KAAK,EAAE,SAASC,KAAKA,CAACC,OAAO,EAAEC,KAAK,EAAE;MACpC,IAAI,CAACD,OAAO,GAAGA,OAAO;MACtB,IAAIU,GAAG,GAAGV,OAAO,CAACU,GAAG;MACrB,IAAIM,MAAM,GAAG8J,WAAW,CAACD,UAAU,CAACnK,GAAG,EAAET,KAAK,GAAG,CAAC,CAAC;MACnD,IAAI,CAACoC,UAAU,GAAG,IAAI/D,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;MAC1CA,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;MAC1CA,MAAM,GAAG,IAAI,CAAC+B,YAAY,CAAC/B,MAAM,CAAC;MAClC,OAAOA,MAAM;IACf;EACF,CAAC,CAAC,EAAE,CAAC;IACHpB,GAAG,EAAE,YAAY;IACjBE,KAAK,EAAE,SAAS+K,UAAUA,CAACnK,GAAG,EAAEM,MAAM,EAAE;MACtC,IAAIE,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAEpB,OAAOE,EAAE,EAAE;QACT,IAAIA,EAAE,KAAK,GAAG,EAAE;UACd,IAAIR,GAAG,CAACM,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;UAC7BE,EAAE,GAAGR,GAAG,CAACM,MAAM,IAAI,CAAC,CAAC;QACvB,CAAC,MAAM;UACLE,EAAE,GAAGR,GAAG,CAACM,MAAM,IAAI,CAAC,CAAC;QACvB;MACF;MAEA,OAAOA,MAAM,GAAG,CAAC;IACnB;EACF,CAAC,CAAC,CAAC;EAEH,OAAO8J,WAAW;AACpB,CAAC,CAACtM,IAAI,CAAC;AAEP,SAASuM,aAAaA,CAAC3K,IAAI,EAAEC,KAAK,EAAE;EAClC,QAAQD,IAAI;IACV,KAAKlC,IAAI,CAAC8M,KAAK;MACb,OAAO,IAAIhE,KAAK,CAAC5G,IAAI,EAAEC,KAAK,CAAC;IAE/B,KAAKnC,IAAI,CAAC+J,YAAY;IACtB,KAAK/J,IAAI,CAAC+M,aAAa;MACrB,OAAO,IAAI1D,UAAU,CAACnH,IAAI,EAAEC,KAAK,CAAC;IAEpC,KAAKnC,IAAI,CAACgN,QAAQ;IAClB,KAAKhN,IAAI,CAACiN,QAAQ;MAChB,OAAO,IAAI/B,cAAc,CAAChJ,IAAI,EAAEC,KAAK,CAAC;IAExC,KAAKnC,IAAI,CAACkN,OAAO;IACjB,KAAKlN,IAAI,CAACmN,SAAS;IACnB,KAAKnN,IAAI,CAAC2C,QAAQ;MAChB,OAAO,IAAIV,cAAc,CAACC,IAAI,EAAEC,KAAK,CAAC;IAExC,KAAKnC,IAAI,CAAC4E,OAAO;IACjB,KAAK5E,IAAI,CAACoN,KAAK;MACb,OAAO,IAAIhM,UAAU,CAACc,IAAI,EAAEC,KAAK,CAAC;IAEpC,KAAKnC,IAAI,CAACqN,YAAY;MACpB,OAAO,IAAI1B,WAAW,CAACzJ,IAAI,EAAEC,KAAK,CAAC;IAErC,KAAKnC,IAAI,CAACsN,YAAY;MACpB,OAAO,IAAIV,WAAW,CAAC1K,IAAI,EAAEC,KAAK,CAAC;;IAErC;;IAEA;MACE,OAAO,IAAI;IACb;EACF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,IAAIoL,YAAY,GAAG,aAAa,YAAY;EAC1C,SAASA,YAAYA,CAAA,EAAG;IACtB,IAAInL,KAAK,GAAG,IAAI;IAEhB,IAAIoL,IAAI,GAAGzE,SAAS,CAACvF,MAAM,GAAG,CAAC,IAAIuF,SAAS,CAAC,CAAC,CAAC,KAAKN,SAAS,GAAGM,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAEjF,IAAI0E,IAAI,GAAG1E,SAAS,CAACvF,MAAM,GAAG,CAAC,IAAIuF,SAAS,CAAC,CAAC,CAAC,KAAKN,SAAS,GAAGM,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAC7EtG,WAAW,GAAGgL,IAAI,CAAChL,WAAW;MAC9BkB,YAAY,GAAG8J,IAAI,CAAC9J,YAAY;MAChC4E,MAAM,GAAGkF,IAAI,CAAClF,MAAM;MACpB1F,MAAM,GAAG4K,IAAI,CAAC5K,MAAM;MACpBH,SAAS,GAAG+K,IAAI,CAAC/K,SAAS;MAC1BkB,MAAM,GAAG6J,IAAI,CAAC7J,MAAM;IAExB9D,eAAe,CAAC,IAAI,EAAEyN,YAAY,CAAC;IAEnCrM,eAAe,CAAC,IAAI,EAAE,WAAW,EAAE,UAAUwM,OAAO,EAAE3L,KAAK,EAAE;MAC3D,IAAIzB,IAAI,CAACyH,kBAAkB,CAAC3F,KAAK,CAACI,GAAG,EAAET,KAAK,CAAC,EAAE,OAAO,IAAI;MAC1D,IAAID,OAAO,GAAG,IAAIyL,YAAY,CAACnL,KAAK,EAAEsL,OAAO,CAAC;MAE9C,IAAIC,mBAAmB,GAAG7L,OAAO,CAAC8L,UAAU,CAAC7L,KAAK,CAAC;QAC/CI,KAAK,GAAGwL,mBAAmB,CAACxL,KAAK;QACjCD,IAAI,GAAGyL,mBAAmB,CAACzL,IAAI;QAC/B2L,UAAU,GAAGF,mBAAmB,CAACE,UAAU;MAE/C,IAAIxL,IAAI,GAAGwK,aAAa,CAAC3K,IAAI,EAAEC,KAAK,CAAC;MACrC,IAAIW,MAAM,GAAGT,IAAI,CAACR,KAAK,CAACC,OAAO,EAAE+L,UAAU,CAAC;MAC5CxL,IAAI,CAACL,KAAK,GAAG,IAAI5B,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;MACrC;;MAEA,IAAIA,MAAM,IAAIf,KAAK,EAAE;QACnB;QACA;QACAM,IAAI,CAACO,KAAK,GAAG,IAAIkL,KAAK,CAAC,mCAAmC,CAAC;QAC3DzL,IAAI,CAACO,KAAK,CAACmL,QAAQ,GAAGjL,MAAM;QAC5BT,IAAI,CAACO,KAAK,CAACoL,MAAM,GAAG3L,IAAI;QACxBA,IAAI,CAACL,KAAK,CAACkC,GAAG,GAAGnC,KAAK,GAAG,CAAC;MAC5B;MAEA,IAAID,OAAO,CAACmM,oBAAoB,CAAC5L,IAAI,CAAC,EAAE;QACtC,IAAI,CAACA,IAAI,CAACO,KAAK,IAAI,CAACd,OAAO,CAACW,WAAW,IAAIX,OAAO,CAAC8B,MAAM,CAAC1B,IAAI,KAAKlC,IAAI,CAACyH,QAAQ,EAAE;UAChFpF,IAAI,CAACO,KAAK,GAAG,IAAI9B,eAAe,CAACuB,IAAI,EAAE,uFAAuF,CAAC;QACjI;QAEA,IAAI6L,UAAU,GAAG,IAAIlJ,UAAU,CAAC3C,IAAI,CAAC;QACrCS,MAAM,GAAGoL,UAAU,CAACrM,KAAK,CAAC,IAAI0L,YAAY,CAACzL,OAAO,CAAC,EAAEgB,MAAM,CAAC;QAC5DoL,UAAU,CAAClM,KAAK,GAAG,IAAI5B,KAAK,CAAC2B,KAAK,EAAEe,MAAM,CAAC;QAC3C,OAAOoL,UAAU;MACnB;MAEA,OAAO7L,IAAI;IACb,CAAC,CAAC;IAEF,IAAI,CAACI,WAAW,GAAGA,WAAW,IAAI,IAAI,GAAGA,WAAW,GAAG+K,IAAI,CAAC/K,WAAW,IAAI,KAAK;IAChF,IAAI,CAACkB,YAAY,GAAGA,YAAY,IAAI,IAAI,GAAGA,YAAY,GAAG6J,IAAI,CAAC7J,YAAY,IAAI,KAAK;IACpF,IAAI,CAAC4E,MAAM,GAAGA,MAAM,IAAI,IAAI,GAAGA,MAAM,GAAGiF,IAAI,CAACjF,MAAM,IAAI,KAAK;IAC5D,IAAI,CAAC1F,MAAM,GAAGA,MAAM,IAAI,IAAI,GAAGA,MAAM,GAAG2K,IAAI,CAAC3K,MAAM;IACnD,IAAI,CAACH,SAAS,GAAGA,SAAS,IAAI,IAAI,GAAGA,SAAS,GAAG8K,IAAI,CAAC9K,SAAS;IAC/D,IAAI,CAACkB,MAAM,GAAGA,MAAM,IAAI,IAAI,GAAGA,MAAM,GAAG4J,IAAI,CAAC5J,MAAM,IAAI,CAAC,CAAC;IACzD,IAAI,CAAC8E,IAAI,GAAG8E,IAAI,CAAC9E,IAAI;IACrB,IAAI,CAAClG,GAAG,GAAGgL,IAAI,CAAChL,GAAG;EACrB;EAEAtC,YAAY,CAACqN,YAAY,EAAE,CAAC;IAC1B7L,GAAG,EAAE,sBAAsB;IAC3BE,KAAK,EAAE,SAASqM,oBAAoBA,CAAC5L,IAAI,EAAE;MACzC,IAAIsB,YAAY,GAAG,IAAI,CAACA,YAAY;QAChC4E,MAAM,GAAG,IAAI,CAACA,MAAM;QACpB/F,GAAG,GAAG,IAAI,CAACA,GAAG;MAClB,IAAImB,YAAY,IAAI4E,MAAM,EAAE,OAAO,KAAK;MACxC,IAAIlG,IAAI,YAAYJ,cAAc,EAAE,OAAO,IAAI,CAAC,CAAC;;MAEjD,IAAIa,MAAM,GAAGT,IAAI,CAACL,KAAK,CAACkC,GAAG;MAC3B,IAAI1B,GAAG,CAACM,MAAM,CAAC,KAAK,IAAI,IAAIN,GAAG,CAACM,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE,OAAO,KAAK;MAClEA,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;MAC1C,OAAON,GAAG,CAACM,MAAM,CAAC,KAAK,GAAG;IAC5B,CAAC,CAAC;IACF;EAEF,CAAC,EAAE;IACDpB,GAAG,EAAE,YAAY;IACjBE,KAAK,EAAE,SAASgM,UAAUA,CAAC9K,MAAM,EAAE;MACjC,IAAIyF,MAAM,GAAG,IAAI,CAACA,MAAM;QACpB3E,MAAM,GAAG,IAAI,CAACA,MAAM;QACpBpB,GAAG,GAAG,IAAI,CAACA,GAAG;MAClB,IAAIL,KAAK,GAAG,EAAE;MACd,IAAIgM,YAAY,GAAG,KAAK;MACxBrL,MAAM,GAAG,IAAI,CAACL,WAAW,GAAGnC,IAAI,CAACmD,WAAW,CAACjB,GAAG,EAAEM,MAAM,CAAC,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEM,MAAM,CAAC;MAC7F,IAAIE,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAEpB,OAAOE,EAAE,KAAKhC,IAAI,CAACoN,MAAM,IAAIpL,EAAE,KAAKhC,IAAI,CAAC4D,OAAO,IAAI5B,EAAE,KAAKhC,IAAI,CAACqN,GAAG,IAAIrL,EAAE,KAAK,IAAI,EAAE;QAClF,IAAIA,EAAE,KAAK,IAAI,EAAE;UACf,IAAIsL,KAAK,GAAGxL,MAAM;UAClB,IAAIJ,SAAS,GAAG,KAAK,CAAC;UAEtB,GAAG;YACDA,SAAS,GAAG4L,KAAK,GAAG,CAAC;YACrBA,KAAK,GAAGhO,IAAI,CAACmD,WAAW,CAACjB,GAAG,EAAEE,SAAS,CAAC;UAC1C,CAAC,QAAQF,GAAG,CAAC8L,KAAK,CAAC,KAAK,IAAI;UAE5B,IAAIC,UAAU,GAAGD,KAAK,IAAI5L,SAAS,GAAG,IAAI,CAACG,MAAM,CAAC;UAClD,IAAI2L,mBAAmB,GAAG5K,MAAM,CAAC1B,IAAI,KAAKlC,IAAI,CAAC2C,QAAQ,IAAIiB,MAAM,CAAC9B,OAAO,CAACW,WAAW;UACrF,IAAID,GAAG,CAAC8L,KAAK,CAAC,KAAK,GAAG,IAAI,CAAChO,IAAI,CAACoD,kBAAkB,CAAClB,GAAG,CAAC8L,KAAK,CAAC,EAAEC,UAAU,EAAE,CAACC,mBAAmB,CAAC,EAAE;UAClG,IAAI,CAAC/L,WAAW,GAAG,IAAI;UACvB,IAAI,CAACC,SAAS,GAAGA,SAAS;UAC1ByL,YAAY,GAAG,KAAK;UACpBrL,MAAM,GAAGwL,KAAK;QAChB,CAAC,MAAM,IAAItL,EAAE,KAAKhC,IAAI,CAAC4D,OAAO,EAAE;UAC9B,IAAIV,GAAG,GAAG5D,IAAI,CAAC+C,SAAS,CAACb,GAAG,EAAEM,MAAM,GAAG,CAAC,CAAC;UACzCX,KAAK,CAACmB,IAAI,CAAC,IAAIlD,KAAK,CAAC0C,MAAM,EAAEoB,GAAG,CAAC,CAAC;UAClCpB,MAAM,GAAGoB,GAAG;QACd,CAAC,MAAM;UACL,IAAId,IAAI,GAAG9C,IAAI,CAAC0I,eAAe,CAACxG,GAAG,EAAEM,MAAM,GAAG,CAAC,CAAC;UAEhD,IAAIE,EAAE,KAAKhC,IAAI,CAACqN,GAAG,IAAI7L,GAAG,CAACY,IAAI,CAAC,KAAK,GAAG,IAAI,wDAAwD,CAACiJ,IAAI,CAAC7J,GAAG,CAACgC,KAAK,CAAC1B,MAAM,GAAG,CAAC,EAAEM,IAAI,GAAG,EAAE,CAAC,CAAC,EAAE;YAC3I;YACA;YACA;YACA;YACAA,IAAI,GAAG9C,IAAI,CAAC0I,eAAe,CAACxG,GAAG,EAAEY,IAAI,GAAG,CAAC,CAAC;UAC5C;UAEAjB,KAAK,CAACmB,IAAI,CAAC,IAAIlD,KAAK,CAAC0C,MAAM,EAAEM,IAAI,CAAC,CAAC;UACnC+K,YAAY,GAAG,IAAI;UACnBrL,MAAM,GAAGxC,IAAI,CAACyC,eAAe,CAACP,GAAG,EAAEY,IAAI,CAAC;QAC1C;QAEAJ,EAAE,GAAGR,GAAG,CAACM,MAAM,CAAC;MAClB,CAAC,CAAC;;MAGF,IAAIqL,YAAY,IAAInL,EAAE,KAAK,GAAG,IAAI1C,IAAI,CAAC8F,OAAO,CAAC5D,GAAG,EAAEM,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,EAAEA,MAAM,IAAI,CAAC;MAClF,IAAIZ,IAAI,GAAGqL,YAAY,CAACkB,SAAS,CAACjM,GAAG,EAAEM,MAAM,EAAEyF,MAAM,CAAC;MACtD,OAAO;QACLpG,KAAK,EAAEA,KAAK;QACZD,IAAI,EAAEA,IAAI;QACV2L,UAAU,EAAE/K;MACd,CAAC;IACH;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,CAAC,EAAE,CAAC;IACHpB,GAAG,EAAE,WAAW;IAChBE,KAAK,EAAE,SAAS6M,SAASA,CAACjM,GAAG,EAAEM,MAAM,EAAEyF,MAAM,EAAE;MAC7C,QAAQ/F,GAAG,CAACM,MAAM,CAAC;QACjB,KAAK,GAAG;UACN,OAAO9C,IAAI,CAAC8M,KAAK;QAEnB,KAAK,GAAG;UACN,OAAO9M,IAAI,CAAC+J,YAAY;QAE1B,KAAK,GAAG;UACN,OAAO/J,IAAI,CAAC+M,aAAa;QAE3B,KAAK,GAAG;UACN,OAAO/M,IAAI,CAACgN,QAAQ;QAEtB,KAAK,GAAG;UACN,OAAOhN,IAAI,CAACiN,QAAQ;QAEtB,KAAK,GAAG;UACN,OAAO,CAAC1E,MAAM,IAAIjI,IAAI,CAAC8F,OAAO,CAAC5D,GAAG,EAAEM,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG9C,IAAI,CAACkN,OAAO,GAAGlN,IAAI,CAACoN,KAAK;QAEnF,KAAK,GAAG;UACN,OAAO,CAAC7E,MAAM,IAAIjI,IAAI,CAAC8F,OAAO,CAAC5D,GAAG,EAAEM,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG9C,IAAI,CAACmN,SAAS,GAAGnN,IAAI,CAACoN,KAAK;QAErF,KAAK,GAAG;UACN,OAAO,CAAC7E,MAAM,IAAIjI,IAAI,CAAC8F,OAAO,CAAC5D,GAAG,EAAEM,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG9C,IAAI,CAAC2C,QAAQ,GAAG3C,IAAI,CAACoN,KAAK;QAEpF,KAAK,GAAG;UACN,OAAOpN,IAAI,CAACqN,YAAY;QAE1B,KAAK,GAAG;UACN,OAAOrN,IAAI,CAACsN,YAAY;QAE1B;UACE,OAAOtN,IAAI,CAACoN,KAAK;MACrB;IACF;EACF,CAAC,CAAC,CAAC;EAEH,OAAOG,YAAY;AACrB,CAAC,CAAC,CAAC;;AAEH;AACA,SAAS1L,KAAKA,CAACW,GAAG,EAAE;EAClB,IAAI6B,EAAE,GAAG,EAAE;EAEX,IAAI7B,GAAG,CAACkM,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;IAC5BlM,GAAG,GAAGA,GAAG,CAACmM,OAAO,CAAC,QAAQ,EAAE,UAAUC,KAAK,EAAE9L,MAAM,EAAE;MACnD,IAAI8L,KAAK,CAACpL,MAAM,GAAG,CAAC,EAAEa,EAAE,CAACf,IAAI,CAACR,MAAM,CAAC;MACrC,OAAO,IAAI;IACb,CAAC,CAAC;EACJ;EAEA,IAAI+L,SAAS,GAAG,EAAE;EAClB,IAAI/L,MAAM,GAAG,CAAC;EAEd,GAAG;IACD,IAAIgM,GAAG,GAAG,IAAItH,QAAQ,CAAC,CAAC;IACxB,IAAI1F,OAAO,GAAG,IAAIyL,YAAY,CAAC;MAC7B/K,GAAG,EAAEA;IACP,CAAC,CAAC;IACFM,MAAM,GAAGgM,GAAG,CAACjN,KAAK,CAACC,OAAO,EAAEgB,MAAM,CAAC;IACnC+L,SAAS,CAACvL,IAAI,CAACwL,GAAG,CAAC;EACrB,CAAC,QAAQhM,MAAM,GAAGN,GAAG,CAACgB,MAAM;EAE5BqL,SAAS,CAACzK,aAAa,GAAG,YAAY;IACpC,IAAIC,EAAE,CAACb,MAAM,KAAK,CAAC,EAAE,OAAO,KAAK;IAEjC,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,EAAE,CAACb,MAAM,EAAE,EAAE2B,CAAC,EAAE;MAClCd,EAAE,CAACc,CAAC,CAAC,IAAIA,CAAC;IACZ;IAEA,IAAI4J,QAAQ,GAAG,CAAC;IAEhB,KAAK,IAAIjI,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG+H,SAAS,CAACrL,MAAM,EAAE,EAAEsD,EAAE,EAAE;MAC5CiI,QAAQ,GAAGF,SAAS,CAAC/H,EAAE,CAAC,CAAC1C,aAAa,CAACC,EAAE,EAAE0K,QAAQ,CAAC;IACtD;IAEA1K,EAAE,CAACkB,MAAM,CAAC,CAAC,EAAElB,EAAE,CAACb,MAAM,CAAC;IACvB,OAAO,IAAI;EACb,CAAC;EAEDqL,SAAS,CAACvK,QAAQ,GAAG,YAAY;IAC/B,OAAOuK,SAAS,CAAChG,IAAI,CAAC,OAAO,CAAC;EAChC,CAAC;EAED,OAAOgG,SAAS;AAClB;AAEA,SAAShN,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}