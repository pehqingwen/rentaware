{"ast":null,"code":"const topologicalSort = require(\"./topologicalSort\");\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\nconst VISITED_MARKER = 1;\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n    const siblings = visited[siblingsId];\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n    visited[visitedId] = VISITED_MARKER;\n    siblings.push(importId);\n  }\n}\nmodule.exports = (options = {}) => {\n  let importIndex = 0;\n  const createImportedName = typeof options.createImportedName !== \"function\" ? (importName /*, path*/) => `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}` : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules(rule => {\n            const matches = icssImport.exec(rule.selector);\n            if (matches) {\n              const [, /*match*/doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n              addImportToGraph(importPath, \"root\", graph, visited);\n              existingImports[importPath] = rule;\n            }\n          });\n          root.walkDecls(/^composes$/, declaration => {\n            const multiple = declaration.value.split(\",\");\n            const values = [];\n            multiple.forEach(value => {\n              const matches = value.trim().match(matchImports);\n              if (!matches) {\n                values.push(value);\n                return;\n              }\n              let tmpSymbols;\n              let [, /*match*/symbols, doubleQuotePath, singleQuotePath, global] = matches;\n              if (global) {\n                // Composing globals simply means changing these classes to wrap them in global(name)\n                tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`);\n              } else {\n                const importPath = doubleQuotePath || singleQuotePath;\n                let parent = declaration.parent;\n                let parentIndexes = \"\";\n                while (parent.type !== \"root\") {\n                  parentIndexes = parent.parent.index(parent) + \"_\" + parentIndexes;\n                  parent = parent.parent;\n                }\n                const {\n                  selector\n                } = declaration.parent;\n                const parentRule = `_${parentIndexes}${selector}`;\n                addImportToGraph(importPath, parentRule, graph, visited);\n                importDecls[importPath] = declaration;\n                imports[importPath] = imports[importPath] || {};\n                tmpSymbols = symbols.split(/\\s+/).map(s => {\n                  if (!imports[importPath][s]) {\n                    imports[importPath][s] = createImportedName(s, importPath);\n                  }\n                  return imports[importPath][s];\n                });\n              }\n              values.push(tmpSymbols.join(\" \"));\n            });\n            declaration.value = values.join(\", \");\n          });\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find(importPath =>\n            // eslint-disable-next-line no-prototype-builtins\n            importDecls.hasOwnProperty(importPath));\n            const decl = importDecls[importPath];\n            throw decl.error(\"Failed to resolve order of composed modules \" + importsOrder.nodes.map(importPath => \"`\" + importPath + \"`\").join(\", \") + \".\", {\n              plugin: \"postcss-modules-extract-imports\",\n              word: \"composes\"\n            });\n          }\n          let lastImportRule;\n          importsOrder.forEach(path => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: {\n                  after: \"\\n\"\n                }\n              });\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n            lastImportRule = rule;\n            if (!importedSymbols) {\n              return;\n            }\n            Object.keys(importedSymbols).forEach(importedSymbol => {\n              rule.append(postcss.decl({\n                value: importedSymbol,\n                prop: importedSymbols[importedSymbol],\n                raws: {\n                  before: \"\\n  \"\n                }\n              }));\n            });\n          });\n        }\n      };\n    }\n  };\n};\nmodule.exports.postcss = true;","map":{"version":3,"names":["topologicalSort","require","matchImports","icssImport","VISITED_MARKER","addImportToGraph","importId","parentId","graph","visited","siblingsId","visitedId","Array","isArray","siblings","concat","slice","push","module","exports","options","importIndex","createImportedName","importName","replace","failOnWrongOrder","postcssPlugin","prepare","existingImports","importDecls","imports","Once","root","postcss","walkRules","rule","matches","exec","selector","doubleQuotePath","singleQuotePath","importPath","walkDecls","declaration","multiple","value","split","values","forEach","trim","match","tmpSymbols","symbols","global","map","s","parent","parentIndexes","type","index","parentRule","join","importsOrder","Error","nodes","find","hasOwnProperty","decl","error","plugin","word","lastImportRule","path","importedSymbols","raws","after","insertAfter","prepend","Object","keys","importedSymbol","append","prop","before"],"sources":["C:/Users/pehqi/my-react-app/node_modules/postcss-modules-extract-imports/src/index.js"],"sourcesContent":["const topologicalSort = require(\"./topologicalSort\");\n\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\n\nconst VISITED_MARKER = 1;\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n\n    const siblings = visited[siblingsId];\n\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n\n    visited[visitedId] = VISITED_MARKER;\n\n    siblings.push(importId);\n  }\n}\n\nmodule.exports = (options = {}) => {\n  let importIndex = 0;\n  const createImportedName =\n    typeof options.createImportedName !== \"function\"\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`\n      : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules((rule) => {\n            const matches = icssImport.exec(rule.selector);\n\n            if (matches) {\n              const [, /*match*/ doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              addImportToGraph(importPath, \"root\", graph, visited);\n\n              existingImports[importPath] = rule;\n            }\n          });\n\n          root.walkDecls(/^composes$/, (declaration) => {\n            const multiple = declaration.value.split(\",\");\n            const values = [];\n\n            multiple.forEach((value) => {\n              const matches = value.trim().match(matchImports);\n\n              if (!matches) {\n                values.push(value);\n\n                return;\n              }\n\n              let tmpSymbols;\n              let [\n                ,\n                /*match*/ symbols,\n                doubleQuotePath,\n                singleQuotePath,\n                global,\n              ] = matches;\n\n              if (global) {\n                // Composing globals simply means changing these classes to wrap them in global(name)\n                tmpSymbols = symbols.split(/\\s+/).map((s) => `global(${s})`);\n              } else {\n                const importPath = doubleQuotePath || singleQuotePath;\n\n                let parent = declaration.parent;\n                let parentIndexes = \"\";\n\n                while (parent.type !== \"root\") {\n                  parentIndexes =\n                    parent.parent.index(parent) + \"_\" + parentIndexes;\n                  parent = parent.parent;\n                }\n\n                const { selector } = declaration.parent;\n                const parentRule = `_${parentIndexes}${selector}`;\n\n                addImportToGraph(importPath, parentRule, graph, visited);\n\n                importDecls[importPath] = declaration;\n                imports[importPath] = imports[importPath] || {};\n\n                tmpSymbols = symbols.split(/\\s+/).map((s) => {\n                  if (!imports[importPath][s]) {\n                    imports[importPath][s] = createImportedName(s, importPath);\n                  }\n\n                  return imports[importPath][s];\n                });\n              }\n\n              values.push(tmpSymbols.join(\" \"));\n            });\n\n            declaration.value = values.join(\", \");\n          });\n\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find((importPath) =>\n              // eslint-disable-next-line no-prototype-builtins\n              importDecls.hasOwnProperty(importPath)\n            );\n            const decl = importDecls[importPath];\n\n            throw decl.error(\n              \"Failed to resolve order of composed modules \" +\n                importsOrder.nodes\n                  .map((importPath) => \"`\" + importPath + \"`\")\n                  .join(\", \") +\n                \".\",\n              {\n                plugin: \"postcss-modules-extract-imports\",\n                word: \"composes\",\n              }\n            );\n          }\n\n          let lastImportRule;\n\n          importsOrder.forEach((path) => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: { after: \"\\n\" },\n              });\n\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n\n            lastImportRule = rule;\n\n            if (!importedSymbols) {\n              return;\n            }\n\n            Object.keys(importedSymbols).forEach((importedSymbol) => {\n              rule.append(\n                postcss.decl({\n                  value: importedSymbol,\n                  prop: importedSymbols[importedSymbol],\n                  raws: { before: \"\\n  \" },\n                })\n              );\n            });\n          });\n        },\n      };\n    },\n  };\n};\n\nmodule.exports.postcss = true;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}