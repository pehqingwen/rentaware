{"ast":null,"code":"\"use strict\";\n\nconst NativeModule = require(\"module\");\nconst path = require(\"path\");\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n/** @typedef {import(\"webpack\").Module} Module */\n/** @typedef {import(\"webpack\").LoaderContext<any>} LoaderContext */\n\n/**\n * @returns {boolean}\n */\nfunction trueFn() {\n  return true;\n}\n\n/**\n * @param {Compilation} compilation\n * @param {string | number} id\n * @returns {null | Module}\n */\nfunction findModuleById(compilation, id) {\n  const {\n    modules,\n    chunkGraph\n  } = compilation;\n  for (const module of modules) {\n    const moduleId = typeof chunkGraph !== \"undefined\" ? chunkGraph.getModuleId(module) : module.id;\n    if (moduleId === id) {\n      return module;\n    }\n  }\n  return null;\n}\n\n/**\n * @param {LoaderContext} loaderContext\n * @param {string | Buffer} code\n * @param {string} filename\n * @returns {object}\n */\nfunction evalModuleCode(loaderContext, code, filename) {\n  // @ts-ignore\n  const module = new NativeModule(filename, loaderContext);\n\n  // @ts-ignore\n  module.paths = NativeModule._nodeModulePaths(loaderContext.context); // eslint-disable-line no-underscore-dangle\n  module.filename = filename;\n  // @ts-ignore\n  module._compile(code, filename); // eslint-disable-line no-underscore-dangle\n\n  return module.exports;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns {0 | 1 | -1}\n */\nfunction compareIds(a, b) {\n  if (typeof a !== typeof b) {\n    return typeof a < typeof b ? -1 : 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * @param {Module} a\n * @param {Module} b\n * @returns {0 | 1 | -1}\n */\nfunction compareModulesByIdentifier(a, b) {\n  return compareIds(a.identifier(), b.identifier());\n}\nconst MODULE_TYPE = \"css/mini-extract\";\nconst AUTO_PUBLIC_PATH = \"__mini_css_extract_plugin_public_path_auto__\";\nconst ABSOLUTE_PUBLIC_PATH = \"webpack:///mini-css-extract-plugin/\";\nconst BASE_URI = \"webpack://\";\nconst SINGLE_DOT_PATH_SEGMENT = \"__mini_css_extract_plugin_single_dot_path_segment__\";\n\n/**\n * @param {string} str\n * @returns {boolean}\n */\nfunction isAbsolutePath(str) {\n  return path.posix.isAbsolute(str) || path.win32.isAbsolute(str);\n}\nconst RELATIVE_PATH_REGEXP = /^\\.\\.?[/\\\\]/;\n\n/**\n * @param {string} str\n * @returns {boolean}\n */\nfunction isRelativePath(str) {\n  return RELATIVE_PATH_REGEXP.test(str);\n}\n\n// TODO simplify for the next major release\n/**\n * @param {LoaderContext} loaderContext\n * @param {string} request\n * @returns {string}\n */\nfunction stringifyRequest(loaderContext, request) {\n  if (typeof loaderContext.utils !== \"undefined\" && typeof loaderContext.utils.contextify === \"function\") {\n    return JSON.stringify(loaderContext.utils.contextify(loaderContext.context || loaderContext.rootContext, request));\n  }\n  const splitted = request.split(\"!\");\n  const {\n    context\n  } = loaderContext;\n  return JSON.stringify(splitted.map(part => {\n    // First, separate singlePath from query, because the query might contain paths again\n    const splittedPart = part.match(/^(.*?)(\\?.*)/);\n    const query = splittedPart ? splittedPart[2] : \"\";\n    let singlePath = splittedPart ? splittedPart[1] : part;\n    if (isAbsolutePath(singlePath) && context) {\n      singlePath = path.relative(context, singlePath);\n      if (isAbsolutePath(singlePath)) {\n        // If singlePath still matches an absolute path, singlePath was on a different drive than context.\n        // In this case, we leave the path platform-specific without replacing any separators.\n        // @see https://github.com/webpack/loader-utils/pull/14\n        return singlePath + query;\n      }\n      if (isRelativePath(singlePath) === false) {\n        // Ensure that the relative path starts at least with ./ otherwise it would be a request into the modules directory (like node_modules).\n        singlePath = `./${singlePath}`;\n      }\n    }\n    return singlePath.replace(/\\\\/g, \"/\") + query;\n  }).join(\"!\"));\n}\n\n/**\n * @param {string} filename\n * @param {string} outputPath\n * @param {boolean} enforceRelative\n * @returns {string}\n */\nfunction getUndoPath(filename, outputPath, enforceRelative) {\n  let depth = -1;\n  let append = \"\";\n\n  // eslint-disable-next-line no-param-reassign\n  outputPath = outputPath.replace(/[\\\\/]$/, \"\");\n  for (const part of filename.split(/[/\\\\]+/)) {\n    if (part === \"..\") {\n      if (depth > -1) {\n        // eslint-disable-next-line no-plusplus\n        depth--;\n      } else {\n        const i = outputPath.lastIndexOf(\"/\");\n        const j = outputPath.lastIndexOf(\"\\\\\");\n        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n        if (pos < 0) {\n          return `${outputPath}/`;\n        }\n        append = `${outputPath.slice(pos + 1)}/${append}`;\n\n        // eslint-disable-next-line no-param-reassign\n        outputPath = outputPath.slice(0, pos);\n      }\n    } else if (part !== \".\") {\n      // eslint-disable-next-line no-plusplus\n      depth++;\n    }\n  }\n  return depth > 0 ? `${\"../\".repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;\n}\n\n/**\n *\n * @param {string | function} value\n * @returns {string}\n */\nfunction stringifyLocal(value) {\n  return typeof value === \"function\" ? value.toString() : JSON.stringify(value);\n}\n\n/**\n * @param {string} str string\n * @returns {string} string\n */\nconst toSimpleString = str => {\n  if (`${+str}` === str) {\n    return str;\n  }\n  return JSON.stringify(str);\n};\n\n/**\n * @param {string} str string\n * @returns {string} quoted meta\n */\nconst quoteMeta = str => str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common prefix\n */\nconst getCommonPrefix = items => {\n  let prefix = items[0];\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n    for (let p = 0; p < prefix.length; p++) {\n      if (item[p] !== prefix[p]) {\n        prefix = prefix.slice(0, p);\n        break;\n      }\n    }\n  }\n  return prefix;\n};\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common suffix\n */\nconst getCommonSuffix = items => {\n  let suffix = items[0];\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n    for (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {\n      if (item[p] !== suffix[s]) {\n        suffix = suffix.slice(s + 1);\n        break;\n      }\n    }\n  }\n  return suffix;\n};\n\n/**\n * @param {Set<string>} itemsSet items set\n * @param {(str: string) => string | false} getKey get key function\n * @param {(str: Array<string>) => boolean} condition condition\n * @returns {Array<Array<string>>} list of common items\n */\nconst popCommonItems = (itemsSet, getKey, condition) => {\n  /** @type {Map<string, Array<string>>} */\n  const map = new Map();\n  for (const item of itemsSet) {\n    const key = getKey(item);\n    if (key) {\n      let list = map.get(key);\n      if (list === undefined) {\n        /** @type {Array<string>} */\n        list = [];\n        map.set(key, list);\n      }\n      list.push(item);\n    }\n  }\n\n  /** @type {Array<Array<string>>} */\n  const result = [];\n  for (const list of map.values()) {\n    if (condition(list)) {\n      for (const item of list) {\n        itemsSet.delete(item);\n      }\n      result.push(list);\n    }\n  }\n  return result;\n};\n\n/**\n * @param {Array<string>} itemsArr array of items\n * @returns {string} regexp\n */\nconst itemsToRegexp = itemsArr => {\n  if (itemsArr.length === 1) {\n    return quoteMeta(itemsArr[0]);\n  }\n\n  /** @type {Array<string>} */\n  const finishedItems = [];\n\n  // merge single char items: (a|b|c|d|ef) => ([abcd]|ef)\n  let countOfSingleCharItems = 0;\n  for (const item of itemsArr) {\n    if (item.length === 1) {\n      // eslint-disable-next-line no-plusplus\n      countOfSingleCharItems++;\n    }\n  }\n\n  // special case for only single char items\n  if (countOfSingleCharItems === itemsArr.length) {\n    return `[${quoteMeta(itemsArr.sort().join(\"\"))}]`;\n  }\n  const items = new Set(itemsArr.sort());\n  if (countOfSingleCharItems > 2) {\n    let singleCharItems = \"\";\n    for (const item of items) {\n      if (item.length === 1) {\n        singleCharItems += item;\n        items.delete(item);\n      }\n    }\n    finishedItems.push(`[${quoteMeta(singleCharItems)}]`);\n  }\n\n  // special case for 2 items with common prefix/suffix\n  if (finishedItems.length === 0 && items.size === 2) {\n    const prefix = getCommonPrefix(itemsArr);\n    const suffix = getCommonSuffix(itemsArr.map(item => item.slice(prefix.length)));\n    if (prefix.length > 0 || suffix.length > 0) {\n      return `${quoteMeta(prefix)}${itemsToRegexp(itemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined)))}${quoteMeta(suffix)}`;\n    }\n  }\n\n  // special case for 2 items with common suffix\n  if (finishedItems.length === 0 && items.size === 2) {\n    /** @type {Iterator<string>} */\n    const it = items[Symbol.iterator]();\n    const a = it.next().value;\n    const b = it.next().value;\n    if (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {\n      return `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])}${quoteMeta(a.slice(-1))}`;\n    }\n  }\n\n  // find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)\n  const prefixed = popCommonItems(items, item => item.length >= 1 ? item[0] : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0][1] === list[1][1];\n  });\n  for (const prefixedItems of prefixed) {\n    const prefix = getCommonPrefix(prefixedItems);\n    finishedItems.push(`${quoteMeta(prefix)}${itemsToRegexp(prefixedItems.map(i => i.slice(prefix.length)))}`);\n  }\n\n  // find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)\n  const suffixed = popCommonItems(items, item => item.length >= 1 ? item.slice(-1) : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0].slice(-2) === list[1].slice(-2);\n  });\n  for (const suffixedItems of suffixed) {\n    const suffix = getCommonSuffix(suffixedItems);\n    finishedItems.push(`${itemsToRegexp(suffixedItems.map(i => i.slice(0, -suffix.length)))}${quoteMeta(suffix)}`);\n  }\n\n  // TODO further optimize regexp, i. e.\n  // use ranges: (1|2|3|4|a) => [1-4a]\n  const conditional = finishedItems.concat(Array.from(items, quoteMeta));\n  if (conditional.length === 1) return conditional[0];\n  return `(${conditional.join(\"|\")})`;\n};\n\n/**\n * @param {string[]} positiveItems positive items\n * @param {string[]} negativeItems negative items\n * @returns {function(string): string} a template function to determine the value at runtime\n */\nconst compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {\n  if (positiveItems.length === 0) {\n    return () => \"false\";\n  }\n  if (negativeItems.length === 0) {\n    return () => \"true\";\n  }\n  if (positiveItems.length === 1) {\n    return value => `${toSimpleString(positiveItems[0])} == ${value}`;\n  }\n  if (negativeItems.length === 1) {\n    return value => `${toSimpleString(negativeItems[0])} != ${value}`;\n  }\n  const positiveRegexp = itemsToRegexp(positiveItems);\n  const negativeRegexp = itemsToRegexp(negativeItems);\n  if (positiveRegexp.length <= negativeRegexp.length) {\n    return value => `/^${positiveRegexp}$/.test(${value})`;\n  }\n  return value => `!/^${negativeRegexp}$/.test(${value})`;\n};\n\n// TODO simplify in the next major release and use it from webpack\n/**\n * @param {Record<string|number, boolean>} map value map\n * @returns {boolean|(function(string): string)} true/false, when unconditionally true/false, or a template function to determine the value at runtime\n */\nconst compileBooleanMatcher = map => {\n  const positiveItems = Object.keys(map).filter(i => map[i]);\n  const negativeItems = Object.keys(map).filter(i => !map[i]);\n  if (positiveItems.length === 0) {\n    return false;\n  }\n  if (negativeItems.length === 0) {\n    return true;\n  }\n  return compileBooleanMatcherFromLists(positiveItems, negativeItems);\n};\nmodule.exports = {\n  trueFn,\n  findModuleById,\n  evalModuleCode,\n  compareModulesByIdentifier,\n  MODULE_TYPE,\n  AUTO_PUBLIC_PATH,\n  ABSOLUTE_PUBLIC_PATH,\n  BASE_URI,\n  SINGLE_DOT_PATH_SEGMENT,\n  stringifyRequest,\n  stringifyLocal,\n  getUndoPath,\n  compileBooleanMatcher\n};","map":{"version":3,"names":["NativeModule","require","path","trueFn","findModuleById","compilation","id","modules","chunkGraph","module","moduleId","getModuleId","evalModuleCode","loaderContext","code","filename","paths","_nodeModulePaths","context","_compile","exports","compareIds","a","b","compareModulesByIdentifier","identifier","MODULE_TYPE","AUTO_PUBLIC_PATH","ABSOLUTE_PUBLIC_PATH","BASE_URI","SINGLE_DOT_PATH_SEGMENT","isAbsolutePath","str","posix","isAbsolute","win32","RELATIVE_PATH_REGEXP","isRelativePath","test","stringifyRequest","request","utils","contextify","JSON","stringify","rootContext","splitted","split","map","part","splittedPart","match","query","singlePath","relative","replace","join","getUndoPath","outputPath","enforceRelative","depth","append","i","lastIndexOf","j","pos","Math","max","slice","repeat","stringifyLocal","value","toString","toSimpleString","quoteMeta","getCommonPrefix","items","prefix","length","item","p","getCommonSuffix","suffix","s","popCommonItems","itemsSet","getKey","condition","Map","key","list","get","undefined","set","push","result","values","delete","itemsToRegexp","itemsArr","finishedItems","countOfSingleCharItems","sort","Set","singleCharItems","size","it","Symbol","iterator","next","prefixed","prefixedItems","suffixed","suffixedItems","conditional","concat","Array","from","compileBooleanMatcherFromLists","positiveItems","negativeItems","positiveRegexp","negativeRegexp","compileBooleanMatcher","Object","keys","filter"],"sources":["C:/Users/pehqi/my-react-app/node_modules/mini-css-extract-plugin/dist/utils.js"],"sourcesContent":["\"use strict\";\n\nconst NativeModule = require(\"module\");\nconst path = require(\"path\");\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n/** @typedef {import(\"webpack\").Module} Module */\n/** @typedef {import(\"webpack\").LoaderContext<any>} LoaderContext */\n\n/**\n * @returns {boolean}\n */\nfunction trueFn() {\n  return true;\n}\n\n/**\n * @param {Compilation} compilation\n * @param {string | number} id\n * @returns {null | Module}\n */\nfunction findModuleById(compilation, id) {\n  const {\n    modules,\n    chunkGraph\n  } = compilation;\n  for (const module of modules) {\n    const moduleId = typeof chunkGraph !== \"undefined\" ? chunkGraph.getModuleId(module) : module.id;\n    if (moduleId === id) {\n      return module;\n    }\n  }\n  return null;\n}\n\n/**\n * @param {LoaderContext} loaderContext\n * @param {string | Buffer} code\n * @param {string} filename\n * @returns {object}\n */\nfunction evalModuleCode(loaderContext, code, filename) {\n  // @ts-ignore\n  const module = new NativeModule(filename, loaderContext);\n\n  // @ts-ignore\n  module.paths = NativeModule._nodeModulePaths(loaderContext.context); // eslint-disable-line no-underscore-dangle\n  module.filename = filename;\n  // @ts-ignore\n  module._compile(code, filename); // eslint-disable-line no-underscore-dangle\n\n  return module.exports;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns {0 | 1 | -1}\n */\nfunction compareIds(a, b) {\n  if (typeof a !== typeof b) {\n    return typeof a < typeof b ? -1 : 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * @param {Module} a\n * @param {Module} b\n * @returns {0 | 1 | -1}\n */\nfunction compareModulesByIdentifier(a, b) {\n  return compareIds(a.identifier(), b.identifier());\n}\nconst MODULE_TYPE = \"css/mini-extract\";\nconst AUTO_PUBLIC_PATH = \"__mini_css_extract_plugin_public_path_auto__\";\nconst ABSOLUTE_PUBLIC_PATH = \"webpack:///mini-css-extract-plugin/\";\nconst BASE_URI = \"webpack://\";\nconst SINGLE_DOT_PATH_SEGMENT = \"__mini_css_extract_plugin_single_dot_path_segment__\";\n\n/**\n * @param {string} str\n * @returns {boolean}\n */\nfunction isAbsolutePath(str) {\n  return path.posix.isAbsolute(str) || path.win32.isAbsolute(str);\n}\nconst RELATIVE_PATH_REGEXP = /^\\.\\.?[/\\\\]/;\n\n/**\n * @param {string} str\n * @returns {boolean}\n */\nfunction isRelativePath(str) {\n  return RELATIVE_PATH_REGEXP.test(str);\n}\n\n// TODO simplify for the next major release\n/**\n * @param {LoaderContext} loaderContext\n * @param {string} request\n * @returns {string}\n */\nfunction stringifyRequest(loaderContext, request) {\n  if (typeof loaderContext.utils !== \"undefined\" && typeof loaderContext.utils.contextify === \"function\") {\n    return JSON.stringify(loaderContext.utils.contextify(loaderContext.context || loaderContext.rootContext, request));\n  }\n  const splitted = request.split(\"!\");\n  const {\n    context\n  } = loaderContext;\n  return JSON.stringify(splitted.map(part => {\n    // First, separate singlePath from query, because the query might contain paths again\n    const splittedPart = part.match(/^(.*?)(\\?.*)/);\n    const query = splittedPart ? splittedPart[2] : \"\";\n    let singlePath = splittedPart ? splittedPart[1] : part;\n    if (isAbsolutePath(singlePath) && context) {\n      singlePath = path.relative(context, singlePath);\n      if (isAbsolutePath(singlePath)) {\n        // If singlePath still matches an absolute path, singlePath was on a different drive than context.\n        // In this case, we leave the path platform-specific without replacing any separators.\n        // @see https://github.com/webpack/loader-utils/pull/14\n        return singlePath + query;\n      }\n      if (isRelativePath(singlePath) === false) {\n        // Ensure that the relative path starts at least with ./ otherwise it would be a request into the modules directory (like node_modules).\n        singlePath = `./${singlePath}`;\n      }\n    }\n    return singlePath.replace(/\\\\/g, \"/\") + query;\n  }).join(\"!\"));\n}\n\n/**\n * @param {string} filename\n * @param {string} outputPath\n * @param {boolean} enforceRelative\n * @returns {string}\n */\nfunction getUndoPath(filename, outputPath, enforceRelative) {\n  let depth = -1;\n  let append = \"\";\n\n  // eslint-disable-next-line no-param-reassign\n  outputPath = outputPath.replace(/[\\\\/]$/, \"\");\n  for (const part of filename.split(/[/\\\\]+/)) {\n    if (part === \"..\") {\n      if (depth > -1) {\n        // eslint-disable-next-line no-plusplus\n        depth--;\n      } else {\n        const i = outputPath.lastIndexOf(\"/\");\n        const j = outputPath.lastIndexOf(\"\\\\\");\n        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n        if (pos < 0) {\n          return `${outputPath}/`;\n        }\n        append = `${outputPath.slice(pos + 1)}/${append}`;\n\n        // eslint-disable-next-line no-param-reassign\n        outputPath = outputPath.slice(0, pos);\n      }\n    } else if (part !== \".\") {\n      // eslint-disable-next-line no-plusplus\n      depth++;\n    }\n  }\n  return depth > 0 ? `${\"../\".repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;\n}\n\n/**\n *\n * @param {string | function} value\n * @returns {string}\n */\nfunction stringifyLocal(value) {\n  return typeof value === \"function\" ? value.toString() : JSON.stringify(value);\n}\n\n/**\n * @param {string} str string\n * @returns {string} string\n */\nconst toSimpleString = str => {\n  if (`${+str}` === str) {\n    return str;\n  }\n  return JSON.stringify(str);\n};\n\n/**\n * @param {string} str string\n * @returns {string} quoted meta\n */\nconst quoteMeta = str => str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common prefix\n */\nconst getCommonPrefix = items => {\n  let prefix = items[0];\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n    for (let p = 0; p < prefix.length; p++) {\n      if (item[p] !== prefix[p]) {\n        prefix = prefix.slice(0, p);\n        break;\n      }\n    }\n  }\n  return prefix;\n};\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common suffix\n */\nconst getCommonSuffix = items => {\n  let suffix = items[0];\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n    for (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {\n      if (item[p] !== suffix[s]) {\n        suffix = suffix.slice(s + 1);\n        break;\n      }\n    }\n  }\n  return suffix;\n};\n\n/**\n * @param {Set<string>} itemsSet items set\n * @param {(str: string) => string | false} getKey get key function\n * @param {(str: Array<string>) => boolean} condition condition\n * @returns {Array<Array<string>>} list of common items\n */\nconst popCommonItems = (itemsSet, getKey, condition) => {\n  /** @type {Map<string, Array<string>>} */\n  const map = new Map();\n  for (const item of itemsSet) {\n    const key = getKey(item);\n    if (key) {\n      let list = map.get(key);\n      if (list === undefined) {\n        /** @type {Array<string>} */\n        list = [];\n        map.set(key, list);\n      }\n      list.push(item);\n    }\n  }\n\n  /** @type {Array<Array<string>>} */\n  const result = [];\n  for (const list of map.values()) {\n    if (condition(list)) {\n      for (const item of list) {\n        itemsSet.delete(item);\n      }\n      result.push(list);\n    }\n  }\n  return result;\n};\n\n/**\n * @param {Array<string>} itemsArr array of items\n * @returns {string} regexp\n */\nconst itemsToRegexp = itemsArr => {\n  if (itemsArr.length === 1) {\n    return quoteMeta(itemsArr[0]);\n  }\n\n  /** @type {Array<string>} */\n  const finishedItems = [];\n\n  // merge single char items: (a|b|c|d|ef) => ([abcd]|ef)\n  let countOfSingleCharItems = 0;\n  for (const item of itemsArr) {\n    if (item.length === 1) {\n      // eslint-disable-next-line no-plusplus\n      countOfSingleCharItems++;\n    }\n  }\n\n  // special case for only single char items\n  if (countOfSingleCharItems === itemsArr.length) {\n    return `[${quoteMeta(itemsArr.sort().join(\"\"))}]`;\n  }\n  const items = new Set(itemsArr.sort());\n  if (countOfSingleCharItems > 2) {\n    let singleCharItems = \"\";\n    for (const item of items) {\n      if (item.length === 1) {\n        singleCharItems += item;\n        items.delete(item);\n      }\n    }\n    finishedItems.push(`[${quoteMeta(singleCharItems)}]`);\n  }\n\n  // special case for 2 items with common prefix/suffix\n  if (finishedItems.length === 0 && items.size === 2) {\n    const prefix = getCommonPrefix(itemsArr);\n    const suffix = getCommonSuffix(itemsArr.map(item => item.slice(prefix.length)));\n    if (prefix.length > 0 || suffix.length > 0) {\n      return `${quoteMeta(prefix)}${itemsToRegexp(itemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined)))}${quoteMeta(suffix)}`;\n    }\n  }\n\n  // special case for 2 items with common suffix\n  if (finishedItems.length === 0 && items.size === 2) {\n    /** @type {Iterator<string>} */\n    const it = items[Symbol.iterator]();\n    const a = it.next().value;\n    const b = it.next().value;\n    if (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {\n      return `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])}${quoteMeta(a.slice(-1))}`;\n    }\n  }\n\n  // find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)\n  const prefixed = popCommonItems(items, item => item.length >= 1 ? item[0] : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0][1] === list[1][1];\n  });\n  for (const prefixedItems of prefixed) {\n    const prefix = getCommonPrefix(prefixedItems);\n    finishedItems.push(`${quoteMeta(prefix)}${itemsToRegexp(prefixedItems.map(i => i.slice(prefix.length)))}`);\n  }\n\n  // find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)\n  const suffixed = popCommonItems(items, item => item.length >= 1 ? item.slice(-1) : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0].slice(-2) === list[1].slice(-2);\n  });\n  for (const suffixedItems of suffixed) {\n    const suffix = getCommonSuffix(suffixedItems);\n    finishedItems.push(`${itemsToRegexp(suffixedItems.map(i => i.slice(0, -suffix.length)))}${quoteMeta(suffix)}`);\n  }\n\n  // TODO further optimize regexp, i. e.\n  // use ranges: (1|2|3|4|a) => [1-4a]\n  const conditional = finishedItems.concat(Array.from(items, quoteMeta));\n  if (conditional.length === 1) return conditional[0];\n  return `(${conditional.join(\"|\")})`;\n};\n\n/**\n * @param {string[]} positiveItems positive items\n * @param {string[]} negativeItems negative items\n * @returns {function(string): string} a template function to determine the value at runtime\n */\nconst compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {\n  if (positiveItems.length === 0) {\n    return () => \"false\";\n  }\n  if (negativeItems.length === 0) {\n    return () => \"true\";\n  }\n  if (positiveItems.length === 1) {\n    return value => `${toSimpleString(positiveItems[0])} == ${value}`;\n  }\n  if (negativeItems.length === 1) {\n    return value => `${toSimpleString(negativeItems[0])} != ${value}`;\n  }\n  const positiveRegexp = itemsToRegexp(positiveItems);\n  const negativeRegexp = itemsToRegexp(negativeItems);\n  if (positiveRegexp.length <= negativeRegexp.length) {\n    return value => `/^${positiveRegexp}$/.test(${value})`;\n  }\n  return value => `!/^${negativeRegexp}$/.test(${value})`;\n};\n\n// TODO simplify in the next major release and use it from webpack\n/**\n * @param {Record<string|number, boolean>} map value map\n * @returns {boolean|(function(string): string)} true/false, when unconditionally true/false, or a template function to determine the value at runtime\n */\nconst compileBooleanMatcher = map => {\n  const positiveItems = Object.keys(map).filter(i => map[i]);\n  const negativeItems = Object.keys(map).filter(i => !map[i]);\n  if (positiveItems.length === 0) {\n    return false;\n  }\n  if (negativeItems.length === 0) {\n    return true;\n  }\n  return compileBooleanMatcherFromLists(positiveItems, negativeItems);\n};\nmodule.exports = {\n  trueFn,\n  findModuleById,\n  evalModuleCode,\n  compareModulesByIdentifier,\n  MODULE_TYPE,\n  AUTO_PUBLIC_PATH,\n  ABSOLUTE_PUBLIC_PATH,\n  BASE_URI,\n  SINGLE_DOT_PATH_SEGMENT,\n  stringifyRequest,\n  stringifyLocal,\n  getUndoPath,\n  compileBooleanMatcher\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}