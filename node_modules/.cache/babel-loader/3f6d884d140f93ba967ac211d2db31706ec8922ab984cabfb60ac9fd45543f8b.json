{"ast":null,"code":"\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isNestedRule(rule) {\n  if (!rule.parent || rule.parent.type === \"root\") {\n    return false;\n  }\n  if (rule.parent.type === \"rule\") {\n    return true;\n  }\n  return isNestedRule(rule.parent);\n}\nfunction getSingleLocalNamesForComposes(root, rule) {\n  if (isNestedRule(rule)) {\n    throw new Error(`composition is not allowed in nested rule \\n\\n${rule}`);\n  }\n  return root.nodes.map(node => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(`composition is only allowed when selector is single :local class name not in \"${root}\"`);\n    }\n    node = node.nodes[0];\n    if (node.type !== \"pseudo\" || node.value !== \":local\" || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n    node = node.first;\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n    node = node.first;\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n    return node.value;\n  });\n}\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\");\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace ? escaped : high < 0 ?\n    // BMP codepoint\n    String.fromCharCode(high + 0x10000) :\n    // Supplemental Plane codepoint (surrogate pair)\n    String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n  });\n}\nconst plugin = (options = {}) => {\n  const generateScopedName = options && options.generateScopedName || plugin.generateScopedName;\n  const generateExportEntry = options && options.generateExportEntry || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n    Once(root, {\n      rule\n    }) {\n      const exports = Object.create(null);\n      function exportScopedName(name, rawName, node) {\n        const scopedName = generateScopedName(rawName ? rawName : name, root.source.input.from, root.source.input.css, node);\n        const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root.source.input.from, root.source.input.css, node);\n        const {\n          key,\n          value\n        } = exportEntry;\n        exports[key] = exports[key] || [];\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n        return scopedName;\n      }\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map(item => localizeNode(item));\n            return node;\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null, node)\n            });\n          case \"id\":\n            {\n              return selectorParser.id({\n                value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null, node)\n              });\n            }\n          case \"attribute\":\n            {\n              if (node.attribute === \"class\" && node.operator === \"=\") {\n                return selectorParser.attribute({\n                  attribute: node.attribute,\n                  operator: node.operator,\n                  quoteMark: \"'\",\n                  value: exportScopedName(node.value, null, null)\n                });\n              }\n            }\n        }\n        throw new Error(`${node.type} (\"${node}\") is not allowed in a :local block`);\n      }\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n              const selector = localizeNode(node.first);\n              // move the spaces that were around the pseudo selector to the first\n              // non-container node\n              selector.first.spaces = node.spaces;\n              const nextNode = node.next();\n              if (nextNode && nextNode.type === \"combinator\" && nextNode.value === \" \" && /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)) {\n                selector.last.spaces.after = \" \";\n              }\n              node.replaceWith(selector);\n              return;\n            }\n          /* falls through */\n          case \"root\":\n          case \"selector\":\n            {\n              node.each(item => traverseNode(item));\n              break;\n            }\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n            break;\n        }\n        return node;\n      }\n\n      // Find any :import and remember imported names\n      const importedNames = {};\n      root.walkRules(/^:import\\(.+\\)$/, rule => {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      });\n\n      // Find any :local selectors\n      root.walkRules(rule => {\n        let parsedSelector = selectorParser().astSync(rule);\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n        rule.walkDecls(/^(composes|compose-with)$/i, decl => {\n          const localNames = getSingleLocalNamesForComposes(parsedSelector, decl.parent);\n          const multiple = decl.value.split(\",\");\n          multiple.forEach(value => {\n            const classes = value.trim().split(/\\s+/);\n            classes.forEach(className => {\n              const global = /^global\\(([^)]+)\\)$/.exec(className);\n              if (global) {\n                localNames.forEach(exportedName => {\n                  exports[exportedName].push(global[1]);\n                });\n              } else if (hasOwnProperty.call(importedNames, className)) {\n                localNames.forEach(exportedName => {\n                  exports[exportedName].push(className);\n                });\n              } else if (hasOwnProperty.call(exports, className)) {\n                localNames.forEach(exportedName => {\n                  exports[className].forEach(item => {\n                    exports[exportedName].push(item);\n                  });\n                });\n              } else {\n                throw decl.error(`referenced class name \"${className}\" in ${decl.prop} not found`);\n              }\n            });\n          });\n          decl.remove();\n        });\n\n        // Find any :local values\n        rule.walkDecls(decl => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n              return result;\n            } else {\n              return token;\n            }\n          });\n          decl.value = tokens.join(\"\");\n        });\n      });\n\n      // Find any :local keyframes\n      root.walkAtRules(/keyframes$/i, atRule => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n        if (!localMatch) {\n          return;\n        }\n        atRule.params = exportScopedName(localMatch[1]);\n      });\n      root.walkAtRules(/scope$/i, atRule => {\n        if (atRule.params) {\n          atRule.params = atRule.params.split(\"to\").map(item => {\n            const selector = item.trim().slice(1, -1).trim();\n            const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(selector);\n            if (!localMatch) {\n              return `(${selector})`;\n            }\n            let parsedSelector = selectorParser().astSync(selector);\n            return `(${traverseNode(parsedSelector).toString()})`;\n          }).join(\" to \");\n        }\n      });\n\n      // If we found any :locals, insert an :export rule\n      const exportedNames = Object.keys(exports);\n      if (exportedNames.length > 0) {\n        const exportRule = rule({\n          selector: \":export\"\n        });\n        exportedNames.forEach(exportedName => exportRule.append({\n          prop: exportedName,\n          value: exports[exportedName].join(\" \"),\n          raws: {\n            before: \"\\n  \"\n          }\n        }));\n        root.append(exportRule);\n      }\n    }\n  };\n};\nplugin.postcss = true;\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path.replace(/\\.[^./\\\\]+$/, \"\").replace(/[\\W_]+/g, \"_\").replace(/^_|_$/g, \"\");\n  return `_${sanitisedPath}__${name}`.trim();\n};\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName)\n  };\n};\nmodule.exports = plugin;","map":{"version":3,"names":["selectorParser","require","hasOwnProperty","Object","prototype","isNestedRule","rule","parent","type","getSingleLocalNamesForComposes","root","Error","nodes","map","node","length","value","first","whitespace","unescapeRegExp","RegExp","unescape","str","replace","_","escaped","escapedWhitespace","high","String","fromCharCode","plugin","options","generateScopedName","generateExportEntry","exportGlobals","postcssPlugin","Once","exports","create","exportScopedName","name","rawName","scopedName","source","input","from","css","exportEntry","key","indexOf","push","localizeNode","item","className","raws","id","attribute","operator","quoteMark","traverseNode","selector","spaces","nextNode","next","test","last","after","replaceWith","each","importedNames","walkRules","walkDecls","decl","prop","parsedSelector","astSync","clone","toString","localNames","multiple","split","forEach","classes","trim","global","exec","exportedName","call","error","remove","tokens","token","idx","result","localMatch","matchPattern","matchVal","newVal","join","walkAtRules","atRule","params","slice","exportedNames","keys","exportRule","append","before","postcss","path","sanitisedPath","module"],"sources":["C:/Users/pehqi/my-react-app/node_modules/postcss-modules-scope/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isNestedRule(rule) {\n  if (!rule.parent || rule.parent.type === \"root\") {\n    return false;\n  }\n\n  if (rule.parent.type === \"rule\") {\n    return true;\n  }\n\n  return isNestedRule(rule.parent);\n}\n\nfunction getSingleLocalNamesForComposes(root, rule) {\n  if (isNestedRule(rule)) {\n    throw new Error(`composition is not allowed in nested rule \\n\\n${rule}`);\n  }\n\n  return root.nodes.map((node) => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== \"pseudo\" ||\n      node.value !== \":local\" ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\n  \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\",\n  \"ig\"\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n      ? // BMP codepoint\n        String.fromCharCode(high + 0x10000)\n      : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst plugin = (options = {}) => {\n  const generateScopedName =\n    (options && options.generateScopedName) || plugin.generateScopedName;\n  const generateExportEntry =\n    (options && options.generateExportEntry) || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n    Once(root, { rule }) {\n      const exports = Object.create(null);\n\n      function exportScopedName(name, rawName, node) {\n        const scopedName = generateScopedName(\n          rawName ? rawName : name,\n          root.source.input.from,\n          root.source.input.css,\n          node\n        );\n        const exportEntry = generateExportEntry(\n          rawName ? rawName : name,\n          scopedName,\n          root.source.input.from,\n          root.source.input.css,\n          node\n        );\n        const { key, value } = exportEntry;\n\n        exports[key] = exports[key] || [];\n\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n\n        return scopedName;\n      }\n\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map((item) => localizeNode(item));\n            return node;\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null,\n                node\n              ),\n            });\n          case \"id\": {\n            return selectorParser.id({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null,\n                node\n              ),\n            });\n          }\n          case \"attribute\": {\n            if (node.attribute === \"class\" && node.operator === \"=\") {\n              return selectorParser.attribute({\n                attribute: node.attribute,\n                operator: node.operator,\n                quoteMark: \"'\",\n                value: exportScopedName(node.value, null, null),\n              });\n            }\n          }\n        }\n\n        throw new Error(\n          `${node.type} (\"${node}\") is not allowed in a :local block`\n        );\n      }\n\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n\n              const selector = localizeNode(node.first);\n              // move the spaces that were around the pseudo selector to the first\n              // non-container node\n              selector.first.spaces = node.spaces;\n\n              const nextNode = node.next();\n\n              if (\n                nextNode &&\n                nextNode.type === \"combinator\" &&\n                nextNode.value === \" \" &&\n                /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n              ) {\n                selector.last.spaces.after = \" \";\n              }\n\n              node.replaceWith(selector);\n\n              return;\n            }\n          /* falls through */\n          case \"root\":\n          case \"selector\": {\n            node.each((item) => traverseNode(item));\n            break;\n          }\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n            break;\n        }\n        return node;\n      }\n\n      // Find any :import and remember imported names\n      const importedNames = {};\n\n      root.walkRules(/^:import\\(.+\\)$/, (rule) => {\n        rule.walkDecls((decl) => {\n          importedNames[decl.prop] = true;\n        });\n      });\n\n      // Find any :local selectors\n      root.walkRules((rule) => {\n        let parsedSelector = selectorParser().astSync(rule);\n\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n        rule.walkDecls(/^(composes|compose-with)$/i, (decl) => {\n          const localNames = getSingleLocalNamesForComposes(\n            parsedSelector,\n            decl.parent\n          );\n          const multiple = decl.value.split(\",\");\n\n          multiple.forEach((value) => {\n            const classes = value.trim().split(/\\s+/);\n\n            classes.forEach((className) => {\n              const global = /^global\\(([^)]+)\\)$/.exec(className);\n\n              if (global) {\n                localNames.forEach((exportedName) => {\n                  exports[exportedName].push(global[1]);\n                });\n              } else if (hasOwnProperty.call(importedNames, className)) {\n                localNames.forEach((exportedName) => {\n                  exports[exportedName].push(className);\n                });\n              } else if (hasOwnProperty.call(exports, className)) {\n                localNames.forEach((exportedName) => {\n                  exports[className].forEach((item) => {\n                    exports[exportedName].push(item);\n                  });\n                });\n              } else {\n                throw decl.error(\n                  `referenced class name \"${className}\" in ${decl.prop} not found`\n                );\n              }\n            });\n          });\n\n          decl.remove();\n        });\n\n        // Find any :local values\n        rule.walkDecls((decl) => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n\n              return result;\n            } else {\n              return token;\n            }\n          });\n\n          decl.value = tokens.join(\"\");\n        });\n      });\n\n      // Find any :local keyframes\n      root.walkAtRules(/keyframes$/i, (atRule) => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n\n        if (!localMatch) {\n          return;\n        }\n\n        atRule.params = exportScopedName(localMatch[1]);\n      });\n\n      root.walkAtRules(/scope$/i, (atRule) => {\n        if (atRule.params) {\n          atRule.params = atRule.params\n            .split(\"to\")\n            .map((item) => {\n              const selector = item.trim().slice(1, -1).trim();\n\n              const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(selector);\n\n              if (!localMatch) {\n                return `(${selector})`;\n              }\n\n              let parsedSelector = selectorParser().astSync(selector);\n\n              return `(${traverseNode(parsedSelector).toString()})`;\n            })\n            .join(\" to \");\n        }\n      });\n\n      // If we found any :locals, insert an :export rule\n      const exportedNames = Object.keys(exports);\n\n      if (exportedNames.length > 0) {\n        const exportRule = rule({ selector: \":export\" });\n\n        exportedNames.forEach((exportedName) =>\n          exportRule.append({\n            prop: exportedName,\n            value: exports[exportedName].join(\" \"),\n            raws: { before: \"\\n  \" },\n          })\n        );\n\n        root.append(exportRule);\n      }\n    },\n  };\n};\n\nplugin.postcss = true;\n\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^./\\\\]+$/, \"\")\n    .replace(/[\\W_]+/g, \"_\")\n    .replace(/^_|_$/g, \"\");\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nmodule.exports = plugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}