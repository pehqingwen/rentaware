{"ast":null,"code":"/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nconst path = require('path');\nconst {\n  createDebugLogger,\n  formatJoinMessage\n} = require('./debug');\nconst fsUtils = require('./fs-utils');\nconst ITERATION_SAFETY_LIMIT = 100e3;\n\n/**\n * Wrap a function such that it always returns a generator of tuple elements.\n *\n * @param {function({uri:string},...):(Array|Iterator)<[string,string]|string>} fn The function to wrap\n * @returns {function({uri:string},...):(Array|Iterator)<[string,string]>} A function that always returns tuple elements\n */\nconst asGenerator = fn => {\n  const toTuple = defaults => value => {\n    const partial = [].concat(value);\n    return [...partial, ...defaults.slice(partial.length)];\n  };\n  const isTupleUnique = (v, i, a) => {\n    const required = v.join(',');\n    return a.findIndex(vv => vv.join(',') === required) === i;\n  };\n  return (item, ...rest) => {\n    const {\n      uri\n    } = item;\n    const mapTuple = toTuple([null, uri]);\n    const pending = fn(item, ...rest);\n    if (Array.isArray(pending)) {\n      return pending.map(mapTuple).filter(isTupleUnique)[Symbol.iterator]();\n    } else if (pending && typeof pending === 'object' && typeof pending.next === 'function' && pending.next.length === 0) {\n      return pending;\n    } else {\n      throw new TypeError(`in \"join\" function expected \"generator\" to return Array|Iterator`);\n    }\n  };\n};\nexports.asGenerator = asGenerator;\n\n/**\n * A high-level utility to create a join function.\n *\n * The `generator` is responsible for ordering possible base paths. The `operation` is responsible for joining a single\n * `base` path with the given `uri`. The `predicate` is responsible for reporting whether the single joined value is\n * successful as the overall result.\n *\n * Both the `generator` and `operation` may be `function*()` or simply `function(...):Array<string>`.\n *\n * @param {function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (Array<string>|Iterator<string>)} generator A function that takes the hash of base paths from the `engine` and\n *  returns ordered iterable of paths to consider\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join implementation\n */\nconst createJoinImplementation = generator => (item, options, loader) => {\n  const {\n    isAbsolute\n  } = item;\n  const {\n    root\n  } = options;\n  const {\n    fs\n  } = loader;\n\n  // generate the iterator\n  const iterator = generator(item, options, loader);\n  const isValidIterator = iterator && typeof iterator === 'object' && typeof iterator.next === 'function';\n  if (!isValidIterator) {\n    throw new Error('expected generator to return Iterator');\n  }\n\n  // run the iterator lazily and record attempts\n  const {\n    isFileSync,\n    isDirectorySync\n  } = fsUtils(fs);\n  const attempts = [];\n  for (let i = 0; i < ITERATION_SAFETY_LIMIT; i++) {\n    const {\n      value,\n      done\n    } = iterator.next();\n    if (done) {\n      break;\n    } else if (value) {\n      const tuple = Array.isArray(value) && value.length === 2 ? value : null;\n      if (!tuple) {\n        throw new Error('expected Iterator values to be tuple of [string,string], do you need asGenerator utility?');\n      }\n\n      // skip elements where base or uri is non-string\n      // noting that we need to support base=\"\" when root=\"\"\n      const [base, uri] = value;\n      if (typeof base === 'string' && typeof uri === 'string') {\n        // validate\n        const isValidBase = isAbsolute && base === root || path.isAbsolute(base) && isDirectorySync(base);\n        if (!isValidBase) {\n          throw new Error(`expected \"base\" to be absolute path to a valid directory, got \"${base}\"`);\n        }\n\n        // make the attempt\n        const joined = path.normalize(path.join(base, uri));\n        const isFallback = true;\n        const isSuccess = isFileSync(joined);\n        attempts.push({\n          base,\n          uri,\n          joined,\n          isFallback,\n          isSuccess\n        });\n        if (isSuccess) {\n          break;\n        }\n\n        // validate any non-strings are falsey\n      } else {\n        const isValidTuple = value.every(v => typeof v === 'string' || !v);\n        if (!isValidTuple) {\n          throw new Error('expected Iterator values to be tuple of [string,string]');\n        }\n      }\n    }\n  }\n  return attempts;\n};\nexports.createJoinImplementation = createJoinImplementation;\n\n/**\n * A low-level utility to create a join function.\n *\n * The `implementation` function processes an individual `item` and returns an Array of attempts. Each attempt consists\n * of a `base` and a `joined` value with `isSuccessful` and `isFallback` flags.\n *\n * In the case that any attempt `isSuccessful` then its `joined` value is the outcome. Otherwise the first `isFallback`\n * attempt is used. If there is no successful or fallback attempts then `null` is returned indicating no change to the\n * original URI in the CSS.\n *\n * The `attempts` Array is logged to console when in `debug` mode.\n *\n * @param {string} name Name for the resulting join function\n * @param {function({uri:string, query:string, isAbsolute:boolean, bases:{subString:string, value:string,\n *  property:string, selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  Array<{base:string,joined:string,fallback?:string,result?:string}>} implementation A function accepts an item and\n *  returns a list of attempts\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\nconst createJoinFunction = (name, implementation) => {\n  const assertAttempts = value => {\n    const isValid = Array.isArray(value) && value.every(v => v && typeof v === 'object' && typeof v.base === 'string' && typeof v.uri === 'string' && typeof v.joined === 'string' && typeof v.isSuccess === 'boolean' && typeof v.isFallback === 'boolean');\n    if (!isValid) {\n      throw new Error(`expected implementation to return Array of {base, uri, joined, isSuccess, isFallback}`);\n    } else {\n      return value;\n    }\n  };\n  const assertJoined = value => {\n    const isValid = value && typeof value === 'string' && path.isAbsolute(value) || value === null;\n    if (!isValid) {\n      throw new Error(`expected \"joined\" to be absolute path, got \"${value}\"`);\n    } else {\n      return value;\n    }\n  };\n  const join = (options, loader) => {\n    const {\n      debug\n    } = options;\n    const {\n      resourcePath\n    } = loader;\n    const log = createDebugLogger(debug);\n    return item => {\n      const {\n        uri\n      } = item;\n      const attempts = implementation(item, options, loader);\n      assertAttempts(attempts, !!debug);\n      const {\n        joined: fallback\n      } = attempts.find(({\n        isFallback\n      }) => isFallback) || {};\n      const {\n        joined: result\n      } = attempts.find(({\n        isSuccess\n      }) => isSuccess) || {};\n      log(formatJoinMessage, [resourcePath, uri, attempts]);\n      return assertJoined(result || fallback || null);\n    };\n  };\n  const toString = () => '[Function ' + name + ']';\n  return Object.assign(join, !!name && {\n    toString,\n    toJSON: toString\n  });\n};\nexports.createJoinFunction = createJoinFunction;\n\n/**\n * The default iterable factory will order `subString` then `value` then `property` then `selector`.\n *\n * @param {string} uri The uri given in the file webpack is processing\n * @param {boolean} isAbsolute True for absolute URIs, false for relative URIs\n * @param {string} subString A possible base path\n * @param {string} value A possible base path\n * @param {string} property A possible base path\n * @param {string} selector A possible base path\n * @param {string} root The loader options.root value where given\n * @returns {Array<string>} An iterable of possible base paths in preference order\n */\nconst defaultJoinGenerator = asGenerator(({\n  uri,\n  isAbsolute,\n  bases: {\n    subString,\n    value,\n    property,\n    selector\n  }\n}, {\n  root\n}) => isAbsolute ? [root] : [subString, value, property, selector]);\nexports.defaultJoinGenerator = defaultJoinGenerator;\n\n/**\n * @type {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\nexports.defaultJoin = createJoinFunction('defaultJoin', createJoinImplementation(defaultJoinGenerator));","map":{"version":3,"names":["path","require","createDebugLogger","formatJoinMessage","fsUtils","ITERATION_SAFETY_LIMIT","asGenerator","fn","toTuple","defaults","value","partial","concat","slice","length","isTupleUnique","v","i","a","required","join","findIndex","vv","item","rest","uri","mapTuple","pending","Array","isArray","map","filter","Symbol","iterator","next","TypeError","exports","createJoinImplementation","generator","options","loader","isAbsolute","root","fs","isValidIterator","Error","isFileSync","isDirectorySync","attempts","done","tuple","base","isValidBase","joined","normalize","isFallback","isSuccess","push","isValidTuple","every","createJoinFunction","name","implementation","assertAttempts","isValid","assertJoined","debug","resourcePath","log","fallback","find","result","toString","Object","assign","toJSON","defaultJoinGenerator","bases","subString","property","selector","defaultJoin"],"sources":["C:/Users/pehqi/my-react-app/node_modules/resolve-url-loader/lib/join-function/index.js"],"sourcesContent":["/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nconst path = require('path');\n\nconst { createDebugLogger, formatJoinMessage } = require('./debug');\nconst fsUtils = require('./fs-utils');\n\nconst ITERATION_SAFETY_LIMIT = 100e3;\n\n/**\n * Wrap a function such that it always returns a generator of tuple elements.\n *\n * @param {function({uri:string},...):(Array|Iterator)<[string,string]|string>} fn The function to wrap\n * @returns {function({uri:string},...):(Array|Iterator)<[string,string]>} A function that always returns tuple elements\n */\nconst asGenerator = (fn) => {\n  const toTuple = (defaults) => (value) => {\n    const partial = [].concat(value);\n    return [...partial, ...defaults.slice(partial.length)];\n  };\n\n  const isTupleUnique = (v, i, a) => {\n    const required = v.join(',');\n    return a.findIndex((vv) => vv.join(',') === required) === i;\n  };\n\n  return (item, ...rest) => {\n    const {uri} = item;\n    const mapTuple = toTuple([null, uri]);\n    const pending = fn(item, ...rest);\n    if (Array.isArray(pending)) {\n      return pending.map(mapTuple).filter(isTupleUnique)[Symbol.iterator]();\n    } else if (\n      pending &&\n      (typeof pending === 'object') &&\n      (typeof pending.next === 'function') &&\n      (pending.next.length === 0)\n    ) {\n      return pending;\n    } else {\n      throw new TypeError(`in \"join\" function expected \"generator\" to return Array|Iterator`);\n    }\n  };\n};\n\nexports.asGenerator = asGenerator;\n\n/**\n * A high-level utility to create a join function.\n *\n * The `generator` is responsible for ordering possible base paths. The `operation` is responsible for joining a single\n * `base` path with the given `uri`. The `predicate` is responsible for reporting whether the single joined value is\n * successful as the overall result.\n *\n * Both the `generator` and `operation` may be `function*()` or simply `function(...):Array<string>`.\n *\n * @param {function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (Array<string>|Iterator<string>)} generator A function that takes the hash of base paths from the `engine` and\n *  returns ordered iterable of paths to consider\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join implementation\n */\nconst createJoinImplementation = (generator) => (item, options, loader) => {\n  const { isAbsolute } = item;\n  const { root } = options;\n  const { fs } = loader;\n\n  // generate the iterator\n  const iterator = generator(item, options, loader);\n  const isValidIterator = iterator && typeof iterator === 'object' && typeof iterator.next === 'function';\n  if (!isValidIterator) {\n    throw new Error('expected generator to return Iterator');\n  }\n\n  // run the iterator lazily and record attempts\n  const { isFileSync, isDirectorySync } = fsUtils(fs);\n  const attempts = [];\n  for (let i = 0; i < ITERATION_SAFETY_LIMIT; i++) {\n    const { value, done } = iterator.next();\n    if (done) {\n      break;\n    } else if (value) {\n      const tuple = Array.isArray(value) && value.length === 2 ? value : null;\n      if (!tuple) {\n        throw new Error('expected Iterator values to be tuple of [string,string], do you need asGenerator utility?');\n      }\n\n      // skip elements where base or uri is non-string\n      // noting that we need to support base=\"\" when root=\"\"\n      const [base, uri] = value;\n      if ((typeof base === 'string') && (typeof uri === 'string')) {\n\n        // validate\n        const isValidBase = (isAbsolute && base === root) || (path.isAbsolute(base) && isDirectorySync(base));\n        if (!isValidBase) {\n          throw new Error(`expected \"base\" to be absolute path to a valid directory, got \"${base}\"`);\n        }\n\n        // make the attempt\n        const joined = path.normalize(path.join(base, uri));\n        const isFallback = true;\n        const isSuccess = isFileSync(joined);\n        attempts.push({base, uri, joined, isFallback, isSuccess});\n\n        if (isSuccess) {\n          break;\n        }\n\n      // validate any non-strings are falsey\n      } else {\n        const isValidTuple = value.every((v) => (typeof v === 'string') || !v);\n        if (!isValidTuple) {\n          throw new Error('expected Iterator values to be tuple of [string,string]');\n        }\n      }\n    }\n  }\n\n  return attempts;\n};\n\nexports.createJoinImplementation = createJoinImplementation;\n\n/**\n * A low-level utility to create a join function.\n *\n * The `implementation` function processes an individual `item` and returns an Array of attempts. Each attempt consists\n * of a `base` and a `joined` value with `isSuccessful` and `isFallback` flags.\n *\n * In the case that any attempt `isSuccessful` then its `joined` value is the outcome. Otherwise the first `isFallback`\n * attempt is used. If there is no successful or fallback attempts then `null` is returned indicating no change to the\n * original URI in the CSS.\n *\n * The `attempts` Array is logged to console when in `debug` mode.\n *\n * @param {string} name Name for the resulting join function\n * @param {function({uri:string, query:string, isAbsolute:boolean, bases:{subString:string, value:string,\n *  property:string, selector:string}}, {filename:string, fs:Object, debug:function|boolean, root:string}):\n *  Array<{base:string,joined:string,fallback?:string,result?:string}>} implementation A function accepts an item and\n *  returns a list of attempts\n * @returns {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\nconst createJoinFunction = (name, implementation) => {\n  const assertAttempts = (value) => {\n    const isValid =\n      Array.isArray(value) && value.every((v) =>\n        v &&\n        (typeof v === 'object') &&\n        (typeof v.base === 'string') &&\n        (typeof v.uri === 'string') &&\n        (typeof v.joined === 'string') &&\n        (typeof v.isSuccess === 'boolean') &&\n        (typeof v.isFallback === 'boolean')\n      );\n    if (!isValid) {\n      throw new Error(`expected implementation to return Array of {base, uri, joined, isSuccess, isFallback}`);\n    } else {\n      return value;\n    }\n  };\n\n  const assertJoined = (value) => {\n    const isValid = value && (typeof value === 'string') && path.isAbsolute(value) || (value === null);\n    if (!isValid) {\n      throw new Error(`expected \"joined\" to be absolute path, got \"${value}\"`);\n    } else {\n      return value;\n    }\n  };\n\n  const join = (options, loader) => {\n    const { debug } = options;\n    const { resourcePath } = loader;\n    const log = createDebugLogger(debug);\n\n    return (item) => {\n      const { uri } = item;\n      const attempts = implementation(item, options, loader);\n      assertAttempts(attempts, !!debug);\n\n      const { joined: fallback } = attempts.find(({ isFallback }) => isFallback) || {};\n      const { joined: result } = attempts.find(({ isSuccess }) => isSuccess) || {};\n\n      log(formatJoinMessage, [resourcePath, uri, attempts]);\n\n      return assertJoined(result || fallback || null);\n    };\n  };\n\n  const toString = () => '[Function ' + name + ']';\n\n  return Object.assign(join, !!name && {\n    toString,\n    toJSON: toString\n  });\n};\n\nexports.createJoinFunction = createJoinFunction;\n\n/**\n * The default iterable factory will order `subString` then `value` then `property` then `selector`.\n *\n * @param {string} uri The uri given in the file webpack is processing\n * @param {boolean} isAbsolute True for absolute URIs, false for relative URIs\n * @param {string} subString A possible base path\n * @param {string} value A possible base path\n * @param {string} property A possible base path\n * @param {string} selector A possible base path\n * @param {string} root The loader options.root value where given\n * @returns {Array<string>} An iterable of possible base paths in preference order\n */\nconst defaultJoinGenerator = asGenerator(\n  ({ uri, isAbsolute, bases: { subString, value, property, selector } }, { root }) =>\n    isAbsolute ? [root] : [subString, value, property, selector]\n);\n\nexports.defaultJoinGenerator = defaultJoinGenerator;\n\n/**\n * @type {function({filename:string, fs:Object, debug:function|boolean, root:string}):\n *  (function({uri:string, isAbsolute:boolean, bases:{subString:string, value:string, property:string,\n *  selector:string}}):string)} join function\n */\nexports.defaultJoin = createJoinFunction(\n  'defaultJoin',\n  createJoinImplementation(defaultJoinGenerator)\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}