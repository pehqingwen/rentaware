{"ast":null,"code":"\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\nconst valueParser = require(\"postcss-value-parser\");\nconst {\n  extractICSS\n} = require(\"icss-utils\");\nconst isSpacing = node => node.type === \"combinator\" && node.value === \" \";\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n  nodes.forEach(x => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(item => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n    let newNodes;\n    switch (node.type) {\n      case \"root\":\n        {\n          let resultingGlobal;\n          context.hasPureGlobals = false;\n          newNodes = node.nodes.map(n => {\n            const nContext = {\n              global: context.global,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: false\n            };\n            n = transform(n, nContext);\n            if (typeof resultingGlobal === \"undefined\") {\n              resultingGlobal = nContext.global;\n            } else if (resultingGlobal !== nContext.global) {\n              throw new Error('Inconsistent rule global/local result in rule \"' + node + '\" (multiple selectors must result in the same mode for the rule)');\n            }\n            if (!nContext.hasLocals) {\n              context.hasPureGlobals = true;\n            }\n            return n;\n          });\n          context.global = resultingGlobal;\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n      case \"selector\":\n        {\n          newNodes = node.map(childNode => transform(childNode, context));\n          node = node.clone();\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n      case \"combinator\":\n        {\n          if (isSpacing(node)) {\n            if (context.ignoreNextSpacing) {\n              context.ignoreNextSpacing = false;\n              context.lastWasSpacing = false;\n              context.enforceNoSpacing = false;\n              return null;\n            }\n            context.lastWasSpacing = true;\n            return node;\n          }\n          break;\n        }\n      case \"pseudo\":\n        {\n          let childContext;\n          const isNested = !!node.length;\n          const isScoped = node.value === \":local\" || node.value === \":global\";\n          const isImportExport = node.value === \":import\" || node.value === \":export\";\n          if (isImportExport) {\n            context.hasLocals = true;\n            // :local(.foo)\n          } else if (isNested) {\n            if (isScoped) {\n              if (node.nodes.length === 0) {\n                throw new Error(`${node.value}() can't be empty`);\n              }\n              if (context.inside) {\n                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n              }\n              childContext = {\n                global: node.value === \":global\",\n                inside: node.value,\n                hasLocals: false,\n                explicit: true\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);\n              if (newNodes.length) {\n                const {\n                  before,\n                  after\n                } = node.spaces;\n                const first = newNodes[0];\n                const last = newNodes[newNodes.length - 1];\n                first.spaces = {\n                  before,\n                  after: first.spaces.after\n                };\n                last.spaces = {\n                  before: last.spaces.before,\n                  after\n                };\n              }\n              node = newNodes;\n              break;\n            } else {\n              childContext = {\n                global: context.global,\n                inside: context.inside,\n                lastWasSpacing: true,\n                hasLocals: false,\n                explicit: context.explicit\n              };\n              newNodes = node.map(childNode => {\n                const newContext = {\n                  ...childContext,\n                  enforceNoSpacing: false\n                };\n                const result = transform(childNode, newContext);\n                childContext.global = newContext.global;\n                childContext.hasLocals = newContext.hasLocals;\n                return result;\n              });\n              node = node.clone();\n              node.nodes = normalizeNodeArray(newNodes);\n              if (childContext.hasLocals) {\n                context.hasLocals = true;\n              }\n            }\n            break;\n\n            //:local .foo .bar\n          } else if (isScoped) {\n            if (context.inside) {\n              throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n            }\n            const addBackSpacing = !!node.spaces.before;\n            context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;\n            context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;\n            context.global = node.value === \":global\";\n            context.explicit = true;\n\n            // because this node has spacing that is lost when we remove it\n            // we make up for it by adding an extra combinator in since adding\n            // spacing on the parent selector doesn't work\n            return addBackSpacing ? selectorParser.combinator({\n              value: \" \"\n            }) : null;\n          }\n          break;\n        }\n      case \"id\":\n      case \"class\":\n        {\n          if (!node.value) {\n            throw new Error(\"Invalid class or id selector syntax\");\n          }\n          if (context.global) {\n            break;\n          }\n          const isImportedValue = localAliasMap.has(node.value);\n          const isImportedWithExplicitScope = isImportedValue && context.explicit;\n          if (!isImportedValue || isImportedWithExplicitScope) {\n            const innerNode = node.clone();\n            innerNode.spaces = {\n              before: \"\",\n              after: \"\"\n            };\n            node = selectorParser.pseudo({\n              value: \":local\",\n              nodes: [innerNode],\n              spaces: node.spaces\n            });\n            context.hasLocals = true;\n          }\n          break;\n        }\n      case \"nesting\":\n        {\n          if (node.value === \"&\") {\n            context.hasLocals = true;\n          }\n        }\n    }\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n    return node;\n  };\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false\n  };\n  rootContext.selector = selectorParser(root => {\n    transform(root, rootContext);\n  }).processSync(rule, {\n    updateSelector: false,\n    lossless: true\n  });\n  return rootContext;\n}\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n    case \"function\":\n      if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === \"url\") {\n        node.nodes.map(nestedNode => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n          let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n              break;\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\n// `none` is special value, other is global values\nconst specialKeywords = [\"none\", \"inherit\", \"initial\", \"revert\", \"revert-layer\", \"unset\"];\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n  valueNodes.walk((node, index, nodes) => {\n    if (node.type === \"function\" && (node.value.toLowerCase() === \"var\" || node.value.toLowerCase() === \"env\")) {\n      return false;\n    }\n    if (node.type === \"word\" && specialKeywords.includes(node.value.toLowerCase())) {\n      return;\n    }\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n  declaration.value = valueNodes.toString();\n}\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n  if (isAnimation) {\n    // letter\n    // An uppercase letter or a lowercase letter.\n    //\n    // ident-start code point\n    // A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n    //\n    // ident code point\n    // An ident-start code point, a digit, or U+002D HYPHEN-MINUS (-).\n\n    // We don't validate `hex digits`, because we don't need it, it is work of linters.\n    const validIdent = /^-?([a-z\\u0080-\\uFFFF_]|(\\\\[^\\r\\n\\f])|-(?![0-9]))((\\\\[^\\r\\n\\f])|[a-z\\u0080-\\uFFFF_0-9-])*$/i;\n\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n     animation: infinite infinite;\n     The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n    const animationKeywords = {\n      // animation-direction\n      $normal: 1,\n      $reverse: 1,\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      // animation-fill-mode\n      $forwards: 1,\n      $backwards: 1,\n      $both: 1,\n      // animation-iteration-count\n      $infinite: 1,\n      // animation-play-state\n      $paused: 1,\n      $running: 1,\n      // animation-timing-function\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-out\": 1,\n      \"$ease-in-out\": 1,\n      $linear: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      // Special\n      $none: Infinity,\n      // No matter how many times you write none, it will never be an animation name\n      // Global values\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity,\n      $revert: Infinity,\n      \"$revert-layer\": Infinity\n    };\n    let parsedAnimationKeywords = {};\n    const valueNodes = valueParser(declaration.value).walk(node => {\n      // If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh.\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n        return;\n      }\n      // Do not handle nested functions\n      else if (node.type === \"function\") {\n        return false;\n      }\n      // Ignore all except word\n      else if (node.type !== \"word\") {\n        return;\n      }\n      const value = node.type === \"word\" ? node.value.toLowerCase() : null;\n      let shouldParseAnimationName = false;\n      if (value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] = \"$\" + value in parsedAnimationKeywords ? parsedAnimationKeywords[\"$\" + value] + 1 : 0;\n          shouldParseAnimationName = parsedAnimationKeywords[\"$\" + value] >= animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap\n      };\n      return localizeDeclNode(node, subContext);\n    });\n    declaration.value = valueNodes.toString();\n    return;\n  }\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n  const hasUrl = /url\\(/i.test(declaration.value);\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\nmodule.exports = (options = {}) => {\n  if (options && options.mode && options.mode !== \"global\" && options.mode !== \"local\" && options.mode !== \"pure\") {\n    throw new Error('options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")');\n  }\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n    prepare() {\n      const localAliasMap = new Map();\n      return {\n        Once(root) {\n          const {\n            icssImports\n          } = extractICSS(root, false);\n          Object.keys(icssImports).forEach(key => {\n            Object.keys(icssImports[key]).forEach(prop => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n          root.walkAtRules(atRule => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atRule.params);\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atRule.params);\n              let globalKeyframes = globalMode;\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\"@keyframes :global(...) is not allowed in pure mode\");\n                }\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (atRule.params && !globalMode && !localAliasMap.has(atRule.params)) {\n                atRule.params = \":local(\" + atRule.params + \")\";\n              }\n              atRule.walkDecls(declaration => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes\n                });\n              });\n            } else if (/scope$/i.test(atRule.name)) {\n              if (atRule.params) {\n                atRule.params = atRule.params.split(\"to\").map(item => {\n                  const selector = item.trim().slice(1, -1).trim();\n                  const context = localizeNode(selector, options.mode, localAliasMap);\n                  context.options = options;\n                  context.localAliasMap = localAliasMap;\n                  if (pureMode && context.hasPureGlobals) {\n                    throw atRule.error('Selector in at-rule\"' + selector + '\" is not pure ' + \"(pure selectors must contain at least one local class or id)\");\n                  }\n                  return `(${context.selector})`;\n                }).join(\" to \");\n              }\n              atRule.nodes.forEach(declaration => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode\n                  });\n                }\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach(declaration => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode\n                  });\n                }\n              });\n            }\n          });\n          root.walkRules(rule => {\n            if (rule.parent && rule.parent.type === \"atrule\" && /keyframes$/i.test(rule.parent.name)) {\n              // ignore keyframe rules\n              return;\n            }\n            const context = localizeNode(rule, options.mode, localAliasMap);\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error('Selector \"' + rule.selector + '\" is not pure ' + \"(pure selectors must contain at least one local class or id)\");\n            }\n            rule.selector = context.selector;\n\n            // Less-syntax mixins parse as rules with no nodes\n            if (rule.nodes) {\n              rule.nodes.forEach(declaration => localizeDeclaration(declaration, context));\n            }\n          });\n        }\n      };\n    }\n  };\n};\nmodule.exports.postcss = true;","map":{"version":3,"names":["selectorParser","require","valueParser","extractICSS","isSpacing","node","type","value","normalizeNodeArray","nodes","array","forEach","x","Array","isArray","item","push","length","pop","localizeNode","rule","mode","localAliasMap","transform","context","ignoreNextSpacing","Error","enforceNoSpacing","newNodes","resultingGlobal","hasPureGlobals","map","n","nContext","global","lastWasSpacing","hasLocals","explicit","childNode","clone","childContext","isNested","isScoped","isImportExport","inside","reduce","acc","next","concat","before","after","spaces","first","last","newContext","result","addBackSpacing","combinator","isImportedValue","has","isImportedWithExplicitScope","innerNode","pseudo","rootContext","selector","root","processSync","updateSelector","lossless","localizeDeclNode","localizeNextItem","options","rewriteUrl","toLowerCase","nestedNode","newUrl","quote","replace","specialKeywords","localizeDeclarationValues","localize","declaration","valueNodes","walk","index","includes","subContext","toString","localizeDeclaration","isAnimation","test","prop","validIdent","animationKeywords","$normal","$reverse","$alternate","$forwards","$backwards","$both","$infinite","$paused","$running","$ease","$linear","$none","Infinity","$initial","$inherit","$unset","$revert","parsedAnimationKeywords","shouldParseAnimationName","isAnimationName","hasUrl","module","exports","pureMode","globalMode","postcssPlugin","prepare","Map","Once","icssImports","Object","keys","key","set","walkAtRules","atRule","name","globalMatch","exec","params","localMatch","globalKeyframes","error","walkDecls","split","trim","slice","join","walkRules","parent","postcss"],"sources":["C:/Users/pehqi/my-react-app/node_modules/postcss-modules-local-by-default/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\nconst valueParser = require(\"postcss-value-parser\");\nconst { extractICSS } = require(\"icss-utils\");\n\nconst isSpacing = (node) => node.type === \"combinator\" && node.value === \" \";\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n\n  nodes.forEach((x) => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach((item) => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case \"root\": {\n        let resultingGlobal;\n\n        context.hasPureGlobals = false;\n\n        newNodes = node.nodes.map((n) => {\n          const nContext = {\n            global: context.global,\n            lastWasSpacing: true,\n            hasLocals: false,\n            explicit: false,\n          };\n\n          n = transform(n, nContext);\n\n          if (typeof resultingGlobal === \"undefined\") {\n            resultingGlobal = nContext.global;\n          } else if (resultingGlobal !== nContext.global) {\n            throw new Error(\n              'Inconsistent rule global/local result in rule \"' +\n                node +\n                '\" (multiple selectors must result in the same mode for the rule)'\n            );\n          }\n\n          if (!nContext.hasLocals) {\n            context.hasPureGlobals = true;\n          }\n\n          return n;\n        });\n\n        context.global = resultingGlobal;\n\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"selector\": {\n        newNodes = node.map((childNode) => transform(childNode, context));\n\n        node = node.clone();\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"combinator\": {\n        if (isSpacing(node)) {\n          if (context.ignoreNextSpacing) {\n            context.ignoreNextSpacing = false;\n            context.lastWasSpacing = false;\n            context.enforceNoSpacing = false;\n            return null;\n          }\n          context.lastWasSpacing = true;\n          return node;\n        }\n        break;\n      }\n      case \"pseudo\": {\n        let childContext;\n        const isNested = !!node.length;\n        const isScoped = node.value === \":local\" || node.value === \":global\";\n        const isImportExport =\n          node.value === \":import\" || node.value === \":export\";\n\n        if (isImportExport) {\n          context.hasLocals = true;\n          // :local(.foo)\n        } else if (isNested) {\n          if (isScoped) {\n            if (node.nodes.length === 0) {\n              throw new Error(`${node.value}() can't be empty`);\n            }\n\n            if (context.inside) {\n              throw new Error(\n                `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n              );\n            }\n\n            childContext = {\n              global: node.value === \":global\",\n              inside: node.value,\n              hasLocals: false,\n              explicit: true,\n            };\n\n            newNodes = node\n              .map((childNode) => transform(childNode, childContext))\n              .reduce((acc, next) => acc.concat(next.nodes), []);\n\n            if (newNodes.length) {\n              const { before, after } = node.spaces;\n\n              const first = newNodes[0];\n              const last = newNodes[newNodes.length - 1];\n\n              first.spaces = { before, after: first.spaces.after };\n              last.spaces = { before: last.spaces.before, after };\n            }\n\n            node = newNodes;\n\n            break;\n          } else {\n            childContext = {\n              global: context.global,\n              inside: context.inside,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: context.explicit,\n            };\n            newNodes = node.map((childNode) => {\n              const newContext = {\n                ...childContext,\n                enforceNoSpacing: false,\n              };\n\n              const result = transform(childNode, newContext);\n\n              childContext.global = newContext.global;\n              childContext.hasLocals = newContext.hasLocals;\n\n              return result;\n            });\n\n            node = node.clone();\n            node.nodes = normalizeNodeArray(newNodes);\n\n            if (childContext.hasLocals) {\n              context.hasLocals = true;\n            }\n          }\n          break;\n\n          //:local .foo .bar\n        } else if (isScoped) {\n          if (context.inside) {\n            throw new Error(\n              `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n            );\n          }\n\n          const addBackSpacing = !!node.spaces.before;\n\n          context.ignoreNextSpacing = context.lastWasSpacing\n            ? node.value\n            : false;\n\n          context.enforceNoSpacing = context.lastWasSpacing\n            ? false\n            : node.value;\n\n          context.global = node.value === \":global\";\n          context.explicit = true;\n\n          // because this node has spacing that is lost when we remove it\n          // we make up for it by adding an extra combinator in since adding\n          // spacing on the parent selector doesn't work\n          return addBackSpacing\n            ? selectorParser.combinator({ value: \" \" })\n            : null;\n        }\n        break;\n      }\n      case \"id\":\n      case \"class\": {\n        if (!node.value) {\n          throw new Error(\"Invalid class or id selector syntax\");\n        }\n\n        if (context.global) {\n          break;\n        }\n\n        const isImportedValue = localAliasMap.has(node.value);\n        const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n        if (!isImportedValue || isImportedWithExplicitScope) {\n          const innerNode = node.clone();\n          innerNode.spaces = { before: \"\", after: \"\" };\n\n          node = selectorParser.pseudo({\n            value: \":local\",\n            nodes: [innerNode],\n            spaces: node.spaces,\n          });\n\n          context.hasLocals = true;\n        }\n\n        break;\n      }\n      case \"nesting\": {\n        if (node.value === \"&\") {\n          context.hasLocals = true;\n        }\n      }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false,\n  };\n\n  rootContext.selector = selectorParser((root) => {\n    transform(root, rootContext);\n  }).processSync(rule, { updateSelector: false, lossless: true });\n\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n\n    case \"function\":\n      if (\n        context.options &&\n        context.options.rewriteUrl &&\n        node.value.toLowerCase() === \"url\"\n      ) {\n        node.nodes.map((nestedNode) => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(\n            context.global,\n            nestedNode.value\n          );\n\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\n// `none` is special value, other is global values\nconst specialKeywords = [\n  \"none\",\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"revert-layer\",\n  \"unset\",\n];\n\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n\n  valueNodes.walk((node, index, nodes) => {\n    if (\n      node.type === \"function\" &&\n      (node.value.toLowerCase() === \"var\" || node.value.toLowerCase() === \"env\")\n    ) {\n      return false;\n    }\n\n    if (\n      node.type === \"word\" &&\n      specialKeywords.includes(node.value.toLowerCase())\n    ) {\n      return;\n    }\n\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n\n  declaration.value = valueNodes.toString();\n}\n\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n\n  if (isAnimation) {\n    // letter\n    // An uppercase letter or a lowercase letter.\n    //\n    // ident-start code point\n    // A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n    //\n    // ident code point\n    // An ident-start code point, a digit, or U+002D HYPHEN-MINUS (-).\n\n    // We don't validate `hex digits`, because we don't need it, it is work of linters.\n    const validIdent =\n      /^-?([a-z\\u0080-\\uFFFF_]|(\\\\[^\\r\\n\\f])|-(?![0-9]))((\\\\[^\\r\\n\\f])|[a-z\\u0080-\\uFFFF_0-9-])*$/i;\n\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n\n    animation: infinite infinite;\n\n    The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n    const animationKeywords = {\n      // animation-direction\n      $normal: 1,\n      $reverse: 1,\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      // animation-fill-mode\n      $forwards: 1,\n      $backwards: 1,\n      $both: 1,\n      // animation-iteration-count\n      $infinite: 1,\n      // animation-play-state\n      $paused: 1,\n      $running: 1,\n      // animation-timing-function\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-out\": 1,\n      \"$ease-in-out\": 1,\n      $linear: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      // Special\n      $none: Infinity, // No matter how many times you write none, it will never be an animation name\n      // Global values\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity,\n      $revert: Infinity,\n      \"$revert-layer\": Infinity,\n    };\n    let parsedAnimationKeywords = {};\n    const valueNodes = valueParser(declaration.value).walk((node) => {\n      // If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh.\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n\n        return;\n      }\n      // Do not handle nested functions\n      else if (node.type === \"function\") {\n        return false;\n      }\n      // Ignore all except word\n      else if (node.type !== \"word\") {\n        return;\n      }\n\n      const value = node.type === \"word\" ? node.value.toLowerCase() : null;\n\n      let shouldParseAnimationName = false;\n\n      if (value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] =\n            \"$\" + value in parsedAnimationKeywords\n              ? parsedAnimationKeywords[\"$\" + value] + 1\n              : 0;\n\n          shouldParseAnimationName =\n            parsedAnimationKeywords[\"$\" + value] >=\n            animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap,\n      };\n\n      return localizeDeclNode(node, subContext);\n    });\n\n    declaration.value = valueNodes.toString();\n\n    return;\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n\n  const hasUrl = /url\\(/i.test(declaration.value);\n\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\n\nmodule.exports = (options = {}) => {\n  if (\n    options &&\n    options.mode &&\n    options.mode !== \"global\" &&\n    options.mode !== \"local\" &&\n    options.mode !== \"pure\"\n  ) {\n    throw new Error(\n      'options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")'\n    );\n  }\n\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n    prepare() {\n      const localAliasMap = new Map();\n\n      return {\n        Once(root) {\n          const { icssImports } = extractICSS(root, false);\n\n          Object.keys(icssImports).forEach((key) => {\n            Object.keys(icssImports[key]).forEach((prop) => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n\n          root.walkAtRules((atRule) => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n\n              let globalKeyframes = globalMode;\n\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\n                    \"@keyframes :global(...) is not allowed in pure mode\"\n                  );\n                }\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (\n                atRule.params &&\n                !globalMode &&\n                !localAliasMap.has(atRule.params)\n              ) {\n                atRule.params = \":local(\" + atRule.params + \")\";\n              }\n\n              atRule.walkDecls((declaration) => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes,\n                });\n              });\n            } else if (/scope$/i.test(atRule.name)) {\n              if (atRule.params) {\n                atRule.params = atRule.params\n                  .split(\"to\")\n                  .map((item) => {\n                    const selector = item.trim().slice(1, -1).trim();\n                    const context = localizeNode(\n                      selector,\n                      options.mode,\n                      localAliasMap\n                    );\n\n                    context.options = options;\n                    context.localAliasMap = localAliasMap;\n\n                    if (pureMode && context.hasPureGlobals) {\n                      throw atRule.error(\n                        'Selector in at-rule\"' +\n                          selector +\n                          '\" is not pure ' +\n                          \"(pure selectors must contain at least one local class or id)\"\n                      );\n                    }\n\n                    return `(${context.selector})`;\n                  })\n                  .join(\" to \");\n              }\n\n              atRule.nodes.forEach((declaration) => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode,\n                  });\n                }\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach((declaration) => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode,\n                  });\n                }\n              });\n            }\n          });\n\n          root.walkRules((rule) => {\n            if (\n              rule.parent &&\n              rule.parent.type === \"atrule\" &&\n              /keyframes$/i.test(rule.parent.name)\n            ) {\n              // ignore keyframe rules\n              return;\n            }\n\n            const context = localizeNode(rule, options.mode, localAliasMap);\n\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error(\n                'Selector \"' +\n                  rule.selector +\n                  '\" is not pure ' +\n                  \"(pure selectors must contain at least one local class or id)\"\n              );\n            }\n\n            rule.selector = context.selector;\n\n            // Less-syntax mixins parse as rules with no nodes\n            if (rule.nodes) {\n              rule.nodes.forEach((declaration) =>\n                localizeDeclaration(declaration, context)\n              );\n            }\n          });\n        },\n      };\n    },\n  };\n};\nmodule.exports.postcss = true;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}