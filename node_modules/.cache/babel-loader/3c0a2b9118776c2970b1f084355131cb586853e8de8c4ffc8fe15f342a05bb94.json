{"ast":null,"code":"\"use strict\";\n\nconst ICSSUtils = require(\"icss-utils\");\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?(.*?)$/;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\nmodule.exports = options => {\n  let importIndex = 0;\n  const createImportedName = options && options.createImportedName || ((importName /*, path*/) => `i__const_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`);\n  return {\n    postcssPlugin: \"postcss-modules-values\",\n    prepare(result) {\n      const importAliases = [];\n      const definitions = {};\n      return {\n        Once(root, postcss) {\n          root.walkAtRules(/value/i, atRule => {\n            const matches = atRule.params.match(matchImports);\n            if (matches) {\n              let [, /*match*/aliases, path] = matches;\n\n              // We can use constants for path names\n              if (definitions[path]) {\n                path = definitions[path];\n              }\n              const imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, \"$1\").split(/\\s*,\\s*/).map(alias => {\n                const tokens = matchImport.exec(alias);\n                if (tokens) {\n                  const [, /*match*/theirName, myName = theirName] = tokens;\n                  const importedName = createImportedName(myName);\n                  definitions[myName] = importedName;\n                  return {\n                    theirName,\n                    importedName\n                  };\n                } else {\n                  throw new Error(`@import statement \"${alias}\" is invalid!`);\n                }\n              });\n              importAliases.push({\n                path,\n                imports\n              });\n              atRule.remove();\n              return;\n            }\n            if (atRule.params.indexOf(\"@value\") !== -1) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n            }\n            let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(matchValueDefinition);\n            const normalizedValue = value.replace(/\\/\\*((?!\\*\\/).*?)\\*\\//g, \"\");\n            if (normalizedValue.length === 0) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n              atRule.remove();\n              return;\n            }\n            let isOnlySpace = /^\\s+$/.test(normalizedValue);\n            if (!isOnlySpace) {\n              value = value.trim();\n            }\n\n            // Add to the definitions, knowing that values can refer to each other\n            definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n            atRule.remove();\n          });\n\n          /* If we have no definitions, don't continue */\n          if (!Object.keys(definitions).length) {\n            return;\n          }\n\n          /* Perform replacements */\n          ICSSUtils.replaceSymbols(root, definitions);\n\n          /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */\n          const exportDeclarations = Object.keys(definitions).map(key => postcss.decl({\n            value: definitions[key],\n            prop: key,\n            raws: {\n              before: \"\\n  \"\n            }\n          }));\n\n          /* Add export rules if any */\n          if (exportDeclarations.length > 0) {\n            const exportRule = postcss.rule({\n              selector: \":export\",\n              raws: {\n                after: \"\\n\"\n              }\n            });\n            exportRule.append(exportDeclarations);\n            root.prepend(exportRule);\n          }\n\n          /* Add import rules */\n          importAliases.reverse().forEach(({\n            path,\n            imports\n          }) => {\n            const importRule = postcss.rule({\n              selector: `:import(${path})`,\n              raws: {\n                after: \"\\n\"\n              }\n            });\n            imports.forEach(({\n              theirName,\n              importedName\n            }) => {\n              importRule.append({\n                value: theirName,\n                prop: importedName,\n                raws: {\n                  before: \"\\n  \"\n                }\n              });\n            });\n            root.prepend(importRule);\n          });\n        }\n      };\n    }\n  };\n};\nmodule.exports.postcss = true;","map":{"version":3,"names":["ICSSUtils","require","matchImports","matchValueDefinition","matchImport","module","exports","options","importIndex","createImportedName","importName","replace","postcssPlugin","prepare","result","importAliases","definitions","Once","root","postcss","walkAtRules","atRule","matches","params","match","aliases","path","imports","split","map","alias","tokens","exec","theirName","myName","importedName","Error","push","remove","indexOf","warn","key","value","raws","between","normalizedValue","length","isOnlySpace","test","trim","replaceValueSymbols","Object","keys","replaceSymbols","exportDeclarations","decl","prop","before","exportRule","rule","selector","after","append","prepend","reverse","forEach","importRule"],"sources":["C:/Users/pehqi/my-react-app/node_modules/postcss-modules-values/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst ICSSUtils = require(\"icss-utils\");\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?(.*?)$/;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nmodule.exports = (options) => {\n  let importIndex = 0;\n  const createImportedName =\n    (options && options.createImportedName) ||\n    ((importName /*, path*/) =>\n      `i__const_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`);\n\n  return {\n    postcssPlugin: \"postcss-modules-values\",\n    prepare(result) {\n      const importAliases = [];\n      const definitions = {};\n\n      return {\n        Once(root, postcss) {\n          root.walkAtRules(/value/i, (atRule) => {\n            const matches = atRule.params.match(matchImports);\n\n            if (matches) {\n              let [, /*match*/ aliases, path] = matches;\n\n              // We can use constants for path names\n              if (definitions[path]) {\n                path = definitions[path];\n              }\n\n              const imports = aliases\n                .replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, \"$1\")\n                .split(/\\s*,\\s*/)\n                .map((alias) => {\n                  const tokens = matchImport.exec(alias);\n\n                  if (tokens) {\n                    const [, /*match*/ theirName, myName = theirName] = tokens;\n                    const importedName = createImportedName(myName);\n                    definitions[myName] = importedName;\n                    return { theirName, importedName };\n                  } else {\n                    throw new Error(`@import statement \"${alias}\" is invalid!`);\n                  }\n                });\n\n              importAliases.push({ path, imports });\n\n              atRule.remove();\n\n              return;\n            }\n\n            if (atRule.params.indexOf(\"@value\") !== -1) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n            }\n\n            let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(\n              matchValueDefinition\n            );\n\n            const normalizedValue = value.replace(/\\/\\*((?!\\*\\/).*?)\\*\\//g, \"\");\n\n            if (normalizedValue.length === 0) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n              atRule.remove();\n\n              return;\n            }\n\n            let isOnlySpace = /^\\s+$/.test(normalizedValue);\n\n            if (!isOnlySpace) {\n              value = value.trim();\n            }\n\n            // Add to the definitions, knowing that values can refer to each other\n            definitions[key] = ICSSUtils.replaceValueSymbols(\n              value,\n              definitions\n            );\n\n            atRule.remove();\n          });\n\n          /* If we have no definitions, don't continue */\n          if (!Object.keys(definitions).length) {\n            return;\n          }\n\n          /* Perform replacements */\n          ICSSUtils.replaceSymbols(root, definitions);\n\n          /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */\n          const exportDeclarations = Object.keys(definitions).map((key) =>\n            postcss.decl({\n              value: definitions[key],\n              prop: key,\n              raws: { before: \"\\n  \" },\n            })\n          );\n\n          /* Add export rules if any */\n          if (exportDeclarations.length > 0) {\n            const exportRule = postcss.rule({\n              selector: \":export\",\n              raws: { after: \"\\n\" },\n            });\n\n            exportRule.append(exportDeclarations);\n\n            root.prepend(exportRule);\n          }\n\n          /* Add import rules */\n          importAliases.reverse().forEach(({ path, imports }) => {\n            const importRule = postcss.rule({\n              selector: `:import(${path})`,\n              raws: { after: \"\\n\" },\n            });\n\n            imports.forEach(({ theirName, importedName }) => {\n              importRule.append({\n                value: theirName,\n                prop: importedName,\n                raws: { before: \"\\n  \" },\n              });\n            });\n\n            root.prepend(importRule);\n          });\n        },\n      };\n    },\n  };\n};\n\nmodule.exports.postcss = true;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}