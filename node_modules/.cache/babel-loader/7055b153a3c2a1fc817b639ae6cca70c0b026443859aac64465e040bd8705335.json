{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get(target, property, receiver || target);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n  return ls;\n}\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  var _getSrcInfo = getSrcInfo(cst),\n    lineStarts = _getSrcInfo.lineStarts,\n    src = _getSrcInfo.src;\n  if (!lineStarts || !src || offset > src.length) return null;\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n    lineStarts = _getSrcInfo2.lineStarts,\n    src = _getSrcInfo2.src;\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n    end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n  var errLen = 1;\n  var errEnd = '';\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n    this.start = start;\n    this.end = end || start;\n  }\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n        end = this.end;\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n      var i = offset;\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n      this.origStart = start + i;\n      var nextOffset = i;\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n        start = _this$valueRange.start,\n        end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n              _tag$match2 = _slicedToArray(_tag$match, 3);\n            _tag$match2[0];\n            var handle = _tag$match2[1],\n              suffix = _tag$match2[2];\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n        start = _this$valueRange2.start,\n        end = _this$valueRange2.end;\n      var src = this.context.src;\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n        range = this.range,\n        value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n        ch = src[offset + 1];\n      }\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n  return Node;\n}();\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n  var _super = _createSuper(YAMLError);\n  function YAMLError(name, source, message) {\n    var _this;\n    _classCallCheck(this, YAMLError);\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n          line = _this$linePos$start.line,\n          col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n      delete this.source;\n    }\n  }]);\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n  var _super2 = _createSuper(YAMLReferenceError);\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n  var _super3 = _createSuper(YAMLSemanticError);\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n  var _super4 = _createSuper(YAMLSyntaxError);\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n  var _super5 = _createSuper(YAMLWarning);\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n  return YAMLWarning;\n}(YAMLError);\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n  var _super = _createSuper(PlainValue);\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n        start = _this$valueRange.start,\n        end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n      var str = '';\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n            fold = _Node$foldNewline.fold,\n            offset = _Node$foldNewline.offset;\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n      var ch0 = src[start];\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n        indent = _this$context.indent,\n        inFlow = _this$context.inFlow,\n        src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n        src = context.src;\n      var offset = start;\n      var ch = src[offset];\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n      return offset;\n    }\n  }]);\n  return PlainValue;\n}(Node);\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_defineProperty","value","_inherits","subClass","superClass","create","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","call","e","_construct","Parent","args","Class","a","push","apply","Function","bind","arguments","_isNativeFunction","fn","toString","indexOf","_wrapNativeSuper","_cache","Map","undefined","has","get","set","Wrapper","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","_superPropBase","object","property","hasOwnProperty","_get","receiver","base","desc","getOwnPropertyDescriptor","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toArray","_iterableToArray","Array","isArray","iter","from","_arr","_n","_d","_e","_i","_s","next","done","err","minLen","_arrayLikeToArray","n","slice","name","test","len","arr2","_createForOfIteratorHelper","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","return","Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","defaultTagPrefix","defaultTags","STR","findLineStarts","src","ls","offset","getSrcInfo","cst","lineStarts","context","getLinePos","_getSrcInfo","start","line","col","getLine","_getSrcInfo2","end","getPrettyContext","_ref","maxWidth","substr","halfWidth","Math","round","errLen","errEnd","min","repeat","concat","Range","isEmpty","setOrigRange","cr","origStart","origEnd","nextOffset","copy","orig","Node","type","error","range","valueRange","getPropValue","idx","skipKey","prop","anchor","comments","comment","join","commentHasRequiredWhitespace","header","atBlank","jsonLikeTypes","root","_this$valueRange","tag","verbatim","_tag$match","match","_tag$match2","handle","suffix","_this$valueRange2","parseComment","endOfLine","commentRange","setOrigRanges","forEach","str","addStringTerminator","endOfWhiteSpace","atDocumentBoundary","sep","ch0","prev","ch1","ch2","ch3","endOfIdentifier","ch","isVerbatim","notOk","endOfIndent","startOfLine","endOfBlockIndent","indent","lineStart","inEnd","wsEnd","endAsBlank","nextNodeIsIndented","indentDiff","indicatorAsIndent","normalizeOffset","foldNewline","inCount","fold","YAMLError","_Error","_super","source","message","_this","Error","makePretty","nodeType","linePos","rangeAsLinePos","_this$linePos$start","ctx","YAMLReferenceError","_YAMLError","_super2","YAMLSemanticError","_YAMLError2","_super3","YAMLSyntaxError","_YAMLError3","_super4","YAMLWarning","_YAMLError4","_super5","PlainValue","_Node","_ch","_Node$foldNewline","wsStart","msg","errors","_msg","_errors","parseBlockValue","_this$context","inFlow","valueEnd","parse","hasComment","C","N","P","R","T","Y","_","b","c","d","g","h","j","k","l","m","q","r"],"sources":["C:/Users/pehqi/my-react-app/node_modules/yaml/browser/dist/PlainValue-b8036b75.js"],"sourcesContent":["function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n                _tag$match2[0];\n                var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}