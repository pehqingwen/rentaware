{"ast":null,"code":"/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nconst path = require('path');\nconst PACKAGE_NAME = require('../../package.json').name;\n\n/**\n * Paths are formatted to have posix style path separators and those within the CWD are made relative to CWD.\n *\n * @param {string} absolutePath An absolute path to format\n * @returns {string} the formatted path\n */\nconst pathToString = absolutePath => {\n  if (absolutePath === '') {\n    return '-empty-';\n  } else {\n    const relative = path.relative(process.cwd(), absolutePath).split(path.sep);\n    const segments = relative[0] !== '..' ? ['.'].concat(relative).filter(Boolean) : relative.lastIndexOf('..') < 2 ? relative : absolutePath.split(path.sep);\n    return segments.join('/');\n  }\n};\nexports.pathToString = pathToString;\n\n/**\n * Format a debug message.\n *\n * @param {string} filename The file being processed by webpack\n * @param {string} uri A uri path, relative or absolute\n * @param {Array<{base:string,joined:string,isSuccess:boolean}>} attempts An array of attempts, possibly empty\n * @return {string} Formatted message\n */\nconst formatJoinMessage = (filename, uri, attempts) => {\n  const attemptToCells = (_, i, array) => {\n    const {\n      base: prev\n    } = i === 0 ? {} : array[i - 1];\n    const {\n      base: curr,\n      joined\n    } = array[i];\n    return [curr === prev ? '' : pathToString(curr), pathToString(joined)];\n  };\n  const formatCells = lines => {\n    const maxWidth = lines.reduce((max, [cellA]) => Math.max(max, cellA.length), 0);\n    return lines.map(([cellA, cellB]) => [cellA.padEnd(maxWidth), cellB]).map(cells => cells.join(' --> '));\n  };\n  return [PACKAGE_NAME + ': ' + pathToString(filename) + ': ' + uri].concat(attempts.length === 0 ? '-empty-' : formatCells(attempts.map(attemptToCells))).concat(attempts.some(({\n    isSuccess\n  }) => isSuccess) ? 'FOUND' : 'NOT FOUND').join('\\n  ');\n};\nexports.formatJoinMessage = formatJoinMessage;\n\n/**\n * A factory for a log function predicated on the given debug parameter.\n *\n * The logging function created accepts a function that formats a message and parameters that the function utilises.\n * Presuming the message function may be expensive we only call it if logging is enabled.\n *\n * The log messages are de-duplicated based on the parameters, so it is assumed they are simple types that stringify\n * well.\n *\n * @param {function|boolean} debug A boolean or debug function\n * @return {function(function, array):void} A logging function possibly degenerate\n */\nconst createDebugLogger = debug => {\n  const log = !!debug && (typeof debug === 'function' ? debug : console.log);\n  const cache = {};\n  return log ? (msgFn, params) => {\n    const key = Function.prototype.toString.call(msgFn) + JSON.stringify(params);\n    if (!cache[key]) {\n      cache[key] = true;\n      log(msgFn.apply(null, params));\n    }\n  } : () => undefined;\n};\nexports.createDebugLogger = createDebugLogger;","map":{"version":3,"names":["path","require","PACKAGE_NAME","name","pathToString","absolutePath","relative","process","cwd","split","sep","segments","concat","filter","Boolean","lastIndexOf","join","exports","formatJoinMessage","filename","uri","attempts","attemptToCells","_","i","array","base","prev","curr","joined","formatCells","lines","maxWidth","reduce","max","cellA","Math","length","map","cellB","padEnd","cells","some","isSuccess","createDebugLogger","debug","log","console","cache","msgFn","params","key","Function","prototype","toString","call","JSON","stringify","apply","undefined"],"sources":["C:/Users/pehqi/my-react-app/node_modules/resolve-url-loader/lib/join-function/debug.js"],"sourcesContent":["/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nconst path = require('path');\n\nconst PACKAGE_NAME = require('../../package.json').name;\n\n/**\n * Paths are formatted to have posix style path separators and those within the CWD are made relative to CWD.\n *\n * @param {string} absolutePath An absolute path to format\n * @returns {string} the formatted path\n */\nconst pathToString = (absolutePath) => {\n  if (absolutePath === '') {\n    return '-empty-';\n  } else {\n    const relative = path.relative(process.cwd(), absolutePath).split(path.sep);\n    const segments =\n      (relative[0] !== '..') ? ['.'].concat(relative).filter(Boolean) :\n        (relative.lastIndexOf('..') < 2) ? relative :\n          absolutePath.split(path.sep);\n    return segments.join('/');\n  }\n};\n\nexports.pathToString = pathToString;\n\n/**\n * Format a debug message.\n *\n * @param {string} filename The file being processed by webpack\n * @param {string} uri A uri path, relative or absolute\n * @param {Array<{base:string,joined:string,isSuccess:boolean}>} attempts An array of attempts, possibly empty\n * @return {string} Formatted message\n */\nconst formatJoinMessage = (filename, uri, attempts) => {\n  const attemptToCells = (_, i, array) => {\n    const { base: prev } = (i === 0) ? {} : array[i-1];\n    const { base: curr, joined } = array[i];\n    return [(curr === prev) ? '' : pathToString(curr), pathToString(joined)];\n  };\n\n  const formatCells = (lines) => {\n    const maxWidth = lines.reduce((max, [cellA]) => Math.max(max, cellA.length), 0);\n    return lines.map(([cellA, cellB]) => [cellA.padEnd(maxWidth), cellB]).map((cells) => cells.join(' --> '));\n  };\n\n  return [PACKAGE_NAME + ': ' + pathToString(filename) + ': ' + uri]\n    .concat(attempts.length === 0 ? '-empty-' : formatCells(attempts.map(attemptToCells)))\n    .concat(attempts.some(({ isSuccess }) => isSuccess) ? 'FOUND' : 'NOT FOUND')\n    .join('\\n  ');\n};\n\nexports.formatJoinMessage = formatJoinMessage;\n\n/**\n * A factory for a log function predicated on the given debug parameter.\n *\n * The logging function created accepts a function that formats a message and parameters that the function utilises.\n * Presuming the message function may be expensive we only call it if logging is enabled.\n *\n * The log messages are de-duplicated based on the parameters, so it is assumed they are simple types that stringify\n * well.\n *\n * @param {function|boolean} debug A boolean or debug function\n * @return {function(function, array):void} A logging function possibly degenerate\n */\nconst createDebugLogger = (debug) => {\n  const log = !!debug && ((typeof debug === 'function') ? debug : console.log);\n  const cache = {};\n  return log ?\n    ((msgFn, params) => {\n      const key = Function.prototype.toString.call(msgFn) + JSON.stringify(params);\n      if (!cache[key]) {\n        cache[key] = true;\n        log(msgFn.apply(null, params));\n      }\n    }) :\n    (() => undefined);\n};\n\nexports.createDebugLogger = createDebugLogger;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}